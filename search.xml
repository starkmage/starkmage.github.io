<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS中容易混淆的一些区别</title>
    <url>/2020/05/31/CSS%E6%98%93%E6%B7%B7%E7%82%B9/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul>
<li><strong>背景图像偏移background-position中，用百分比数值和长度值的区别</strong>：<br>1.<em>用百分比数值，图像中描述为 50% 50% 的点（中心点）与元素中描述为 50% 50% 的点（中心点）对齐</em>，如果图像位于 0% 0%，其左上角将放在元素内边距区的左上角。如果图像位置是 100% 100%，会使图像的右下角放在右边距的右下角；<br>2.用长度值时，<em>长度值解释的是元素内边距区左上角的偏移</em>，偏移点是图像的左上角。<a id="more"></a>

</li>
</ul>
<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><ul>
<li><strong>text-align:center和&lt;center&gt;的区别</strong>：<br>1.text-align <em>不会控制元素的对齐，而只影响内部内容</em>，元素本身不会从一段移到另一端，只是其中的文本受影响；<br>2.&lt;center&gt;不仅影响文本，还会<em>把整个元素居中</em>。</li>
</ul>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><ul>
<li><strong>id和class的区别</strong>：<br>1.id 属性为一个元素分配一个唯一的名字，每个名字只能在被赋予的页面使用一次。（例如，假如你的页面包含 id 为 content 的 div，那么另外一个 div 或者其他别的元素都不能使用这个名字；<br>2.class 属性可以被一遍又一遍地使用在页面中（例如，页面中的五个段落都可以使用名为 “small” 或者 “footnote” 的 class 名称）；<br>3.在这个例子中，名为 searchform 的 div 被用来封装包含搜索表单的页面区域，而 div class=”blogentry” 则用来封装 blog 中的每个文章入口。因为在页面中只有一个搜索表单，所以我们选择 id 标注这个唯一的组件，但是 blog 则拥有许多的（文章）入口，所以 class 属性被应用于这种情况。同样地，新闻站点通常拥有多个 div，这些 div 的 class 可以命名为 “newsitem” 或者别的什么。 然而不是所有的站点都需要 div。blog 站点可以仅仅使用 h1 和 h2 标题和 &lt;p&gt;段落，新闻站点也一样。我们在这里展示 class 为 blogentry 的 div，并不是鼓励你在站点中塞满 div，而仅仅是为了向你展示这个原则：在同一个 HTML 文档中，使用多次 class，但只能使用一次 id。<pre><code class="html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"searchform"</span>&gt;</span>
Search form components go here. This section of the page is unique.
<span class="tag">&lt;/<span class="name">div</span>&gt;</span> 
<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blogentry"</span>&gt;</span>
  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Today's blog post<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> 
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Blog content goes here.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> 
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here is another paragraph of blog content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> 
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Just as there can be many paragraphs on a page, so too there may be many entries in a blog. A blog page could use multiple instances of the class "blogentry" (or any other class).<span class="tag">&lt;/<span class="name">p</span>&gt;</span> 
<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre>
<pre><code class="html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blogentry"</span>&gt;</span>
  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Yesterday's blog post<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>In fact, here we are inside another div of class "blogentry."<span class="tag">&lt;/<span class="name">p</span>&gt;</span>
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>They reproduce like rabbits.<span class="tag">&lt;/<span class="name">p</span>&gt;</span>
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>If there are ten blog posts on this page, there might be ten divs of class "blogentry" as well.<span class="tag">&lt;/<span class="name">p</span>&gt;</span>
<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre>
</li>
</ul>
<h4 id="边框、边距"><a href="#边框、边距" class="headerlink" title="边框、边距"></a>边框、边距</h4><ul>
<li>padding 通过百分比数值测定时，百分数值是相对于其父元素的 width 计算的，这一点与外边距一样，上下内边距与左右内边距一致，即上下内边距的百分数会相对于父元素宽度设置，而不是相对于高度。如果一个段落的父元素是div元素，那么它的内边距要根据 div 的 width 计算。</li>
</ul>
]]></content>
      <categories>
        <category>切图基础</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习小结(3)—函数</title>
    <url>/2020/06/01/JS%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>JS中函数的定义主要有以下几种方式：</p>
<ul>
<li><p><strong>函数声明</strong><br>被声明的函数不会直接执行，它们被“保存供稍后使用”，当它们被调用时执行。<strong>注意结尾引号的位置，在花括号内</strong>！Hoisting 是 JavaScript 将函数声明移动到当前作用域顶端的默认行为，正因如此，JavaScript 函数能够在声明之前被调用。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = myFunction(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>函数表达式</strong><br>函数表达式可以在变量中存储，在变量中保存函数表达式之后，此变量可用作函数，这实际上是一个匿名函数（没有名称的函数），存放在变量中的函数不需要函数名，他们总是使用变量名调用。<strong>注意结尾引号的位置，在花括号外</strong>！<strong>使用表达式定义的函数不会被提升</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a * b&#125;;</span><br><span class="line"><span class="keyword">var</span> z = x(<span class="number">4</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Function() 构造器</strong><br>函数也可以通过名为 <strong>Function()</strong> 的内建 JavaScript 函数构造器来定义。但是大多数情况下，应该避免在 JavaScript 中使用 new 关键词。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"return a * b"</span>);</span><br><span class="line"><span class="keyword">var</span> x = myFunction(<span class="number">4</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自调用函数</strong><br>函数表达式可以作为“自调用”，假如表达式后面跟着 ()，在不进行调用的情况下，函数表达式会自动执行，我们无法对函数声明进行自调用。需要在函数周围添加括号，以指示它是一个函数表达式，下例实际上是一个匿名的自调用函数（没有名称的函数）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">"Hello!!"</span>;      <span class="comment">//我会调用我自己</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>箭头函数</strong><br>1.ES6新增的方式，IE11 或更早的版本不支持箭头函数；<br>2.箭头函数允许使用简短的语法来编写函数表达式，不需要 function 关键字、return 关键字和花括号；<br>3.箭头函数没有自己的 this，它们不适合定义对象方法；<br>4.箭头函数未被提升，它们必须在使用前进行定义；<br>5.使用 const 比使用 var 更安全，因为函数表达式始终是常量值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x * y;</span><br><span class="line"><span class="keyword">var</span> a = x(<span class="number">3</span>, <span class="number">5</span>);   <span class="comment">//a = 15</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>函数是对象</strong><br>1.JavaScript 中的 typeof 运算符会为函数返回 “function”，但是最好是把 JavaScript 函数描述为对象，JavaScript 函数都有属性和方法；<br>2.定义为对象属性的函数，被称为对象的方法；<br>3.为创建新对象而设计的函数，被称为对象构造函数（对象构造器）；<br>4.toString() 方法以字符串返回函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> txt = myFunction.toString();</span><br><span class="line"><span class="comment">// txt = "function myFunction(a, b) &#123; return a * b; &#125;"</span></span><br></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4></li>
<li><p><strong>JS函数参数的规则</strong>：<br>1.函数参数（parameter）指的是在函数定义中列出的名称；<br>2.函数参数（argument）指的是传递到函数或由函数接收到的真实值；<br>3.JavaScript 函数定义不会为参数（parameter）规定数据类型；<br>4.JavaScript 函数不会对所传递的参数（argument）实行类型检查；<br>5.JavaScript 函数不会检查所接收参数（argument）的数量。</p>
</li>
<li><p>参数默认值<br>如果调用参数时省略了参数（少于被声明的数量），则丢失的值被设置为undefined，有的时候这样没问题，但最好给定默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数通过值传递<br>JavaScript 参数通过值传递：函数只知道值，而不是参数的位置，如果函数改变了参数的值，它不会改变参数的原始值，<strong>参数的改变在函数之外是不可见的</strong>。</p>
</li>
<li><p>对象是由引用传递的<br>在 JavaScript 中，对象引用是值，正因如此，对象的行为就像它们通过引用来传递，如果函数改变了对象属性，它也改变了原始值，<strong>对象属性的改变在函数之外是可见的</strong>。</p>
</li>
</ul>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>函数调用主要有下面3种方式：</p>
<ul>
<li><p><strong>以函数形式调用函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(<span class="number">10</span>, <span class="number">2</span>);           <span class="comment">// 将返回 20</span></span><br><span class="line"><span class="built_in">window</span>.myFunction(<span class="number">10</span>, <span class="number">2</span>);    <span class="comment">// 也会返回 20</span></span><br><span class="line"><span class="comment">//myFunction() 和 window.myFunction() 是同一个函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>作为方法来调用函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    firstName:<span class="string">"Bill"</span>,</span><br><span class="line">    lastName: <span class="string">"Gates"</span>,</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObject.fullName();         <span class="comment">// 将返回 "Bill Gates"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过函数构造器来调用函数</strong><br>如果函数调用的前面是 new 关键字，那么这是一个构造函数调用，它看起来像创建一个新的函数，但由于 JavaScript 函数是对象，实际上创建一个新对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是函数构造器：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = arg1;</span><br><span class="line">    <span class="keyword">this</span>.lastName  = arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个新对象：</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> myFunction(<span class="string">"Bill"</span>, <span class="string">"Gates"</span>);</span><br><span class="line">x.firstName;                             <span class="comment">// 会返回 "Bill"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="函数call"><a href="#函数call" class="headerlink" title="函数call"></a>函数call</h4><ul>
<li><p>函数是对象的方法<br>在 JavaScript 中，函数是对象的方法，如果一个函数不是 JavaScript 对象的方法，那么它就是全局对象的函数。如下例，fullName 属性是一个方法，person 对象是该方法的拥有者，fullName 属性属于 person 对象的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    firstName:<span class="string">"Bill"</span>,</span><br><span class="line">    lastName: <span class="string">"Gates"</span>,</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.fullName();		<span class="comment">// 将返回 "Bill Gates"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>call() 方法</strong><br>call() 方法是预定义的 JavaScript 方法，它可以用来调用所有者对象作为参数的方法，通过 call()，您能够使用属于另一个对象的方法，下例调用 person 的 fullName 方法，并用于 person1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    firstName:<span class="string">"Bill"</span>,</span><br><span class="line">    lastName: <span class="string">"Gates"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    firstName:<span class="string">"Steve"</span>,</span><br><span class="line">    lastName: <span class="string">"Jobs"</span>,</span><br><span class="line">&#125;</span><br><span class="line">person.fullName.call(person1);  <span class="comment">// 将返回 "Bill Gates"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>call() 方法可接受参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params">city, country</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName + <span class="string">","</span> + city + <span class="string">","</span> + country;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  firstName:<span class="string">"Bill"</span>,</span><br><span class="line">  lastName: <span class="string">"Gates"</span></span><br><span class="line">&#125;</span><br><span class="line">person.fullName.call(person1, <span class="string">"Seattle"</span>, <span class="string">"USA"</span>);</span><br><span class="line"><span class="comment">//返回Bill Gates,Seatle,USA</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="函数apply"><a href="#函数apply" class="headerlink" title="函数apply"></a>函数apply</h4><ul>
<li><p>apply() 方法与 call() 方法非常相似：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    firstName: <span class="string">"Bill"</span>,</span><br><span class="line">    lastName: <span class="string">"Gates"</span>,</span><br><span class="line">&#125;</span><br><span class="line">person.fullName.apply(person1);  <span class="comment">// 将返回 "Bill Gates"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>call() 和 apply() 之间的区别</strong>：<br>1.call() 方法分别接受参数；<br>2.apply() 方法接受数组形式的参数，如果要使用数组而不是参数列表，则 apply() 方法非常方便。</p>
</li>
<li><p>带参数的 apply() 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params">city, country</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName + <span class="string">","</span> + city + <span class="string">","</span> + country;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  firstName:<span class="string">"Bill"</span>,</span><br><span class="line">  lastName: <span class="string">"Gates"</span></span><br><span class="line">&#125;</span><br><span class="line">person.fullName.apply(person1, [<span class="string">"Seattle"</span>, <span class="string">"USA"</span>]);</span><br><span class="line"><span class="comment">//返回Bill Gates,Seatle,USA</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在数组上模拟 max 方法<br>因为可以使用 Math.max() 方法找到（数字列表中的）最大数字，而JavaScript 数组没有 max() 方法，因此可以通过apply()应用 Math.max() 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);    <span class="comment">// 会返回 3</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);   <span class="comment">// 也会返回 3</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="string">" "</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);   <span class="comment">// 也会返回 3</span></span><br><span class="line"><span class="comment">//第一个参数是无关紧要的</span></span><br></pre></td></tr></table></figure></li>
<li><p>在 JavaScript 严格模式下，如果 apply() 方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）,在“非严格”模式下，它成为全局对象。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS基础总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习小结(2)—作用域</title>
    <url>/2020/05/31/JS%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h4 id="let和const的一些区别"><a href="#let和const的一些区别" class="headerlink" title="let和const的一些区别"></a>let和const的一些区别</h4><ul>
<li>let和const都是ES6新增的关键词，提供了块作用域变量；</li>
<li>通过let和const都不会被提升到顶端，也就是不能在声明之前使用；<a id="more"></a></li>
<li>使用 JavaScript 的情况下，全局作用域是 JavaScript 环境，在 HTML 中，全局作用域是 window 对象，通过 var 关键词定义的全局变量属于 window 对象，但是通过 let 和const关键词定义的全局变量不属于 window 对象；</li>
<li>const 变量必须在声明时赋值；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI; </span><br><span class="line">PI = <span class="number">3.14159265359</span>;              <span class="comment">// 这是不对的 ​​​</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14159265359</span>;       <span class="comment">//这是对的</span></span><br></pre></td></tr></table></figure></li>
<li>const 有一定的误导性，它没有定义常量值，它定义了对值的常量引用；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.141592653589793</span>; </span><br><span class="line">PI = <span class="number">3.14</span>;                    <span class="comment">// 会出错 </span></span><br><span class="line">PI = PI + <span class="number">10</span>;              <span class="comment">// 也会出错</span></span><br></pre></td></tr></table></figure></li>
<li>const可以更改常量对象的属性、常量数组的元素，但无法重新为常量对象、数组赋值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以创建 const 对象： </span></span><br><span class="line"><span class="keyword">const</span> car = &#123;<span class="attr">type</span>:<span class="string">"porsche"</span>, <span class="attr">model</span>:<span class="string">"911"</span>, <span class="attr">color</span>:<span class="string">"Black"</span>&#125;;  </span><br><span class="line"><span class="comment">// 可以更改属性： </span></span><br><span class="line">car.color = <span class="string">"White"</span>; </span><br><span class="line"><span class="comment">// 可以添加属性： </span></span><br><span class="line">car.owner = <span class="string">"Bill"</span>; </span><br><span class="line">​<span class="comment">//不可以！！！ ​​</span></span><br><span class="line">car = &#123;<span class="attr">type</span>:<span class="string">"Volvo"</span>, <span class="attr">model</span>:<span class="string">"XC60"</span>, <span class="attr">color</span>:<span class="string">"White"</span>&#125;; </span><br><span class="line">​​<span class="comment">// 您可以创建常量数组： </span></span><br><span class="line"><span class="keyword">const</span> cars = [<span class="string">"Audi"</span>, <span class="string">"BMW"</span>, <span class="string">"porsche"</span>]; </span><br><span class="line"><span class="comment">// 您可以更改元素： </span></span><br><span class="line">cars[<span class="number">0</span>] = <span class="string">"Honda"</span>; </span><br><span class="line"><span class="comment">// 您可以添加元素： </span></span><br><span class="line">cars.push(<span class="string">"Volvo"</span>); </span><br><span class="line"><span class="comment">//不可以！！！​ ​​</span></span><br><span class="line">cars = [<span class="string">"Honda"</span>, <span class="string">"Toyota"</span>, <span class="string">"Volvo"</span>];</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="JS不会为每个代码块创建新的作用域"><a href="#JS不会为每个代码块创建新的作用域" class="headerlink" title="JS不会为每个代码块创建新的作用域"></a>JS不会为每个代码块创建新的作用域</h4><ul>
<li><p>很多编程语言虽然会为每个代码块创建新的作用域，但是 JavaScript 并不会为每个代码块创建新的作用域，认为这段代码会返回 undefined是错误的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>JavaScript不会为每个代码块创建新的作用域。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>此代码将显示 i（10）的值，即使在 for 循环块之外：<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="actionscript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span></span><br><span class="line"><span class="actionscript">        &#123; <span class="comment">// some code &#125; </span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = i; </span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>JS基础总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习小结(1)—基础</title>
    <url>/2020/05/31/JS%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>JS同时接受单引号和双引号，两种表达方式注意区分，1为双引号里套单引号，2为单引号里套双引号：<a id="more"></a>
<pre><code class="html">​<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=</span>
<span class="tag">"<span class="attr">document.getElementById</span>('<span class="attr">demo</span>')<span class="attr">.innerHTML</span> = <span class="string">'Hello JavaScript!'</span>"&gt;</span>
单击这里
<span class="tag">&lt;/<span class="name">button</span>&gt;</span>​</code></pre>
<pre><code class="html">​<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=</span>
<span class="tag">'<span class="attr">document.getElementById</span>("<span class="attr">demo</span>")<span class="attr">.innerHTML</span> = <span class="string">"Hello JavaScript!"</span>'&gt;</span>
点击这里
<span class="tag">&lt;/<span class="name">button</span>&gt;</span></code></pre>
</li>
<li>在 HTML 中，JavaScript 代码必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间，旧的 JavaScript 例子或许使用 type 属性：&lt;script type=”text/javascript”&gt;，但type 属性不是必需的，因为JavaScript 是 HTML 中的默认脚本语言。</li>
<li>能够在 HTML 文档中放置任意数量的脚本，脚本可被放置与 HTML 页面的 &lt;body&gt; 或 &lt;head&gt; 部分中，或兼而有之，<strong>但是把脚本置于 &lt;body&gt; 元素的底部，可改善显示速度，因为脚本编译会拖慢显示</strong>。</li>
<li><strong>使用外部脚本的优势</strong>：<br>1.分离了 HTML 和代码；<br>2.使 HTML 和 JavaScript 更易于阅读和维护；<br>3.已缓存的 JavaScript 文件可加速页面加载。</li>
<li>JS语言单行注释以 // 开头，不用结尾，多行注释以 /* 开头，以 */ 结尾。</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><ul>
<li><strong>数值字符串与数值相加时，前后顺序的区别</strong>：<pre><code class="html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> 
<span class="tag">&lt;<span class="name">html</span>&gt;</span>
  <span class="tag">&lt;<span class="name">body</span>&gt;</span>
    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>JavaScript 变量<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>
    <span class="tag">&lt;<span class="name">p</span>&gt;</span>相加的结果是：<span class="tag">&lt;/<span class="name">p</span>&gt;</span> 
    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> 
    ​<span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo2"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> 
    <span class="tag">&lt;<span class="name">script</span>&gt;</span> 
<span class="actionscript">      <span class="keyword">var</span> x = <span class="string">"8"</span> + <span class="number">3</span> + <span class="number">5</span>;      <span class="comment">//输出结果是835 ​</span></span>
<span class="actionscript">      <span class="keyword">var</span> y = <span class="number">3</span> + <span class="number">5</span> + <span class="string">"8"</span>       <span class="comment">//输出结果是88 </span></span>
<span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = x;       </span>
<span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"demo2"</span>).innerHTML = y;​ </span>
    <span class="tag">&lt;/<span class="name">script</span>&gt;</span> 
  <span class="tag">&lt;/<span class="name">body</span>&gt;</span> 
<span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre>
</li>
<li><strong>数字字符串，在所有数字运算中，JavaScript 会尝试将字符串转换为数字，只有+特殊，会被当作字符串串联</strong>：<pre><code class="JS"><span class="keyword">var</span> x = <span class="string">"100"</span>; 
<span class="keyword">var</span> y = <span class="string">"10"</span>; 
<span class="keyword">var</span> a = x + y;     <span class="comment">//a将是10010​ </span>
<span class="keyword">var</span> b = x - y;     <span class="comment">//a将是90 </span>
<span class="keyword">var</span> a = x * y;     <span class="comment">//a将是1000 </span>
<span class="keyword">var</span> d = x / y;     <span class="comment">//z将是 10</span></code></pre>
</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li><strong>空值与undefined不是一回事</strong>：<pre><code class="JS"><span class="keyword">var</span> car = <span class="string">""</span>;     <span class="comment">// 值是 ""，类型是 "string" 空值 ​</span>
<span class="keyword">var</span> person;     <span class="comment">// 值是 undefined，类型是 undefined</span></code></pre>
</li>
<li>在 JavaScript 中，null 是 “nothing”，它被看做不存在的事物，可以通过设置null来清空对象，但<strong>null 的数据类型是对象</strong>，undefined 与 null 的值相等，但类型不相等：<pre><code class="JS"><span class="keyword">var</span> person = <span class="literal">null</span>;     <span class="comment">// 值是 null，但是类型仍然是对象 ​</span>
<span class="keyword">typeof</span> <span class="literal">undefined</span>;    <span class="comment">// undefined</span>
<span class="keyword">typeof</span> <span class="literal">null</span>;        <span class="comment">// object </span>
<span class="literal">null</span> === <span class="literal">undefined</span>;     <span class="comment">// false </span>
<span class="literal">null</span> == <span class="literal">undefined</span>;     <span class="comment">// true</span></code></pre>
</li>
<li>字符串检索，indexOf()：从前往后检索；lastIndexOf()：从后往前检索。</li>
<li><strong>三种提取部分字符串的方法</strong>：<br>1.<strong>slice(start, end)</strong>：参数可以为负，但要注意，用负参数的时候，-1开始计数，小参数在前，大参数在后（var res = str.slice(-13,-7);），如果省略第二个参数，则该方法将裁剪字符串的剩余部分，负值位置不适用 Internet Explorer 8 及其更早版本；<br>2.<strong>substring(start, end)</strong>：会把负参数当作0，如果省略第二个参数，则该 substring() 将裁剪字符串的剩余部分；<br>3.<strong>substr(start, length)</strong>：第二个参数规定被提取部分的长度，首个参数可以为负，第二个参数不能为负，如果为负，会当作0，如果省略了第二个参数，将裁剪字符串的剩余部分。<br>4.<strong>具体的说，slice()和substring()的第二个参数都是指的最后一个字符后面的位置</strong>。</li>
<li><strong>替换字符串内容：str.replace(“a”,”b”)，用b替换str中的a</strong>：<br>1.默认地，replace() 只替换第一个匹配到的内容，如需替换所有匹配，需要使用正则表达式的 g 标志；<br>2.默认地，replace() 对大小写敏感，如需执行大小写不敏感的替换，需要使用正则表达式 /i；<br>3.使用正则表达式时不需要加引号！<pre><code class="JS">str = <span class="string">"Please visit Microsoft and Microsoft!"</span>; 
<span class="keyword">var</span> n = str.replace(<span class="regexp">/Microsoft/g</span>, <span class="string">"W3School"</span>);</code></pre>
<pre><code class="JS">str = <span class="string">"Please visit Microsoft!"</span>; 
<span class="keyword">var</span> n = str.replace(<span class="regexp">/MICROSOFT/i</span>, <span class="string">"W3School"</span>);</code></pre>
</li>
<li>ES5允许对字符串进行属性操作，但不太靠谱！<br>1.不适用 Internet Explorer 7 或更早的版本；<br>2.让字符串看起来像是数组（其实并不是），如果希望按照数组的方式处理字符串，可以用split() 将字符串转换为数组；<br>3.如果找不到字符，[ ] 返回 undefined，而 charAt() 返回空字符串；<br>4.是只读的。<pre><code class="Js"><span class="keyword">var</span> str = <span class="string">"HELLO WORLD"</span>; 
str[<span class="number">0</span>] = <span class="string">"A"</span>;     <span class="comment">// 不产生错误，但不会工作 </span>
str[<span class="number">0</span>];     <span class="comment">// 返回 H</span></code></pre>
</li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul>
<li><p>this关键词，在函数定义中，this 引用该函数的“拥有者”，在下面的例子中，this 指的是“拥有” fullName 函数的 person 对象，换言之，this.firstName 的意思是 this 对象的 firstName 属性：</p>
<pre><code class="JS"><span class="keyword">var</span> person = { 
firstName: <span class="string">"Bill"</span>, 
lastName : <span class="string">"Gates"</span>, 
id : <span class="number">678</span>, 
fullName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
<span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName; } 
};</code></pre>
</li>
<li><p>字符串可以通过关键词 new 定义为对象，<strong>但不要把字符串创建为对象，它会拖慢执行速度，数值也是同理</strong>！</p>
<pre><code class="JS"><span class="keyword">var</span> x = <span class="string">"Bill"</span>;
<span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Bill"</span>);
<span class="keyword">var</span> z = <span class="keyword">new</span> <span class="built_in">String</span>();
z = <span class="string">"Bill"</span>;
<span class="comment">// typeof x 将返回 string</span>
<span class="comment">// typeof y 将返回 object</span>
<span class="comment">// typeof z 将返回 string</span></code></pre>
</li>
<li><p><strong>js中避免使用new()！new只会使代码复杂化，还可能会产生某些不可预期的结果。</strong></p>
</li>
<li><p><strong>JavaScript 对象无法进行对比</strong>，比较两个 JavaScript 将始终返回 false：</p>
<pre><code class="JS"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Bill"</span>); 
<span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Bill"</span>); 
<span class="comment">// (x == y) 为 false，因为 x 和 y 是两个对象（对象无法比较）</span></code></pre>
</li>
<li><p><strong>不同类型值转换时易犯错的地方</strong>：<br>1.”0”：转换为布尔值为true；<br>2.””：转换为数字为0，转换为布尔值为false；<br>3.[]：转换为数字为0，字符串为””，布尔值为true；<br>4.{}：转换为数字为NaN，字符串为”[object Object]”（对象转换为字符串都是这样），布尔值为true；<br>5.null：转换为数字为0，字符串为”null”;<br>6.undefined：转换为数字为NaN，字符串为”undefined”；</p>
</li>
</ul>
<h4 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h4><ul>
<li>获取时间时，一些需要注意的地方：<br>1.getMonth() 以数字（0-11）返回日期的月份，+1才是我们的月份；<br>2.一周的第一天（0）表示“星期日”，即使世界上的一些国家认为周的第一天是“星期一”。</li>
</ul>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li>Switch case 使用的是严格比较（===），值必须与要匹配的类型相同。</li>
</ul>
]]></content>
      <categories>
        <category>JS基础总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习小结(4)—对闭包的讨论</title>
    <url>/2020/06/01/JS%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰，直观的说就是形成一个不销毁的栈环境。<br>简单理解，闭包就是一个函数引用另一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量。或者说闭包就是子函数可以使用父函数的局部变量，还有父函数的参数，即使在父函数关闭之后。这是优点也是缺点，不必要的闭包只会增加内存消耗。</p>
<a id="more"></a>
<h5 id="首先讨论一下全局变量"><a href="#首先讨论一下全局变量" class="headerlink" title="首先讨论一下全局变量"></a>首先讨论一下全局变量</h5><ul>
<li>JavaScript 变量属于本地或全局作用域，全局变量能够通过闭包实现局部（私有）。</li>
<li>全局变量需要注意的几个点：<br>1.在网页中，全局变量属于 window 对象；<br>2.拥有相同名称的全局变量和局部变量是不同的变量。修改一个，不会改变其他；<br>3.<strong>不通过关键词 var 创建的变量总是全局的，即使它们在函数中创建</strong>。</li>
<li>变量的生命周期<br>1.全局变量活得和应用程序（窗口、网页）一样久；<br>2.局部变量活得不长，它们在函数调用时创建，在函数完成后被删除。</li>
</ul>
<h5 id="JS闭包实例讨论"><a href="#JS闭包实例讨论" class="headerlink" title="JS闭包实例讨论"></a>JS闭包实例讨论</h5><ul>
<li><p>在下面的计数器例子中，变量 add 的赋值是自调用函数的返回值，这个自调用函数只运行一次，它设置counter为0，并返回函数表达，这样 add 成为了函数。</p>
</li>
<li><p>add变量可以作为一个函数使用，它能够访问父作用域中的计数器，这被称为 JavaScript 闭包，它使函数拥有“私有”变量成为可能，计数器被这个匿名函数的作用域保护，并且只能使用 add 函数来修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line"><span class="comment">// 计数器目前是 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果把add()换成add,计数器会显示：function () {counter += 1; return counter;}；</p>
</li>
<li><p><strong>为什么上面这段代码没有直接写的 function add (){…} 而是把function赋值给了变量add呢?</strong><br>1.我们通常会想当然的认为每次调用 add() 都会重走一遍add()中的代码块, 但其实不然；<br>2.注意add方法中的return, 它return的并不是1,2,3这样的数值,而是return了一个方法,并且把这个方法赋值给了add变量；<br>3.那么在这个function自运行一遍之后,其实最后赋值给add的是return counter += 1 这段代码；<br>4.所以后面每次调用add() 其实都是在调用return counter += 1，再结合之前所说的, 闭包会持有父方法的局部变量并且不会随父方法销毁而销毁, 所以这个counter其实就是来自于第一次function执行时创建的变量。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS基础总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML个人学习小结</title>
    <url>/2020/05/31/HTML%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="frame框架"><a href="#frame框架" class="headerlink" title="frame框架"></a>frame框架</h3><ul>
<li><p>首先注意！frame、frameset和noframes已经从HTML5删除。</p>
</li>
<li><p>每份html文档称为一个框架，所以frameset标签将窗口分割为多个框架（即多份html文档）。</p>
<a id="more"></a></li>
<li><p>需要为不支持框架的浏览器添加&lt;noframes&gt;标签。特别注意：虽然不能将&lt;body&gt;&lt;/body&gt;标签与&lt;frameset&gt;&lt;/frameset&gt;标签同时使用，但是如果添加包含一段文本的&lt;noframes&gt;标签，就必须将这段文字嵌套于&lt;body&gt;&lt;/body&gt;标签内，参考下例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"25%,50%,25%"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"/example/html/frame_a.html"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"/example/html/frame_b.html"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"/example/html/frame_c.html"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">noframes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>您的浏览器无法处理框架！<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noframes</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>假如一个框架有可见边框，用户可以拖动边框来改变它的大小，为了避免这种情况发生，可以在标签中加入：noresize=”noresize”。如下例，a、b框架之间的边框不可调整，而b、c之间的边框仍然是可以调整的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,*,25%"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"/example/html/frame_a.html"</span> <span class="attr">noresize</span>=<span class="string">"noresize"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"/example/html/frame_b.html"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"/example/html/frame_c.html"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul>
<li><strong>HTML中”bgcolor”与”background-color”的区别</strong>：<br>bgcolor只是标签属性，而backgroud更多作为css的样式属性，它们俩大多数情况下效果完全相同。但在&lt;p&gt;标签下效果不同，&lt;p&gt;不支持bgcolor属性，只能用style标签添加CSS样式。</li>
<li><strong>padding和margin的区别</strong>：<br>padding是指该元素边框线以内的距离，设定之后，该元素内部的非漂浮或定位元素都会距离该元素的边框距离该设定的值的长度，不可以设置负值，不报错，但没有效果；margin是指该元素边框线以外的距离，设定之后，该元素的外边距离所设置方向的元素会相应增加或减少，可以设置负值，会向相反方向移动。</li>
</ul>
<h3 id="script脚本"><a href="#script脚本" class="headerlink" title="script脚本"></a>script脚本</h3><ul>
<li><p>&lt;noscript&gt;标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本。&lt;noscript&gt;元素可包含普通 HTML 页面的 body 元素中能够找到的所有元素。只有在浏览器不支持脚本或者禁用脚本时，才会显示noscript元素中的内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">"Hello World!"</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span>Sorry, your browser does not support JavaScript!<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>不支持 JavaScript 的浏览器将显示 noscript 元素中的文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><strong>如何应对老式浏览器</strong>：<br>如果浏览器压根没法识别&lt;script&gt;标签，那么&lt;script&gt;标签所包含的内容将以文本方式显示在页面上。为了避免这种情况发生，应该将脚本隐藏在注释标签当中。那些老的浏览器（无法识别&lt;script&gt;标签的浏览器）将忽略这些注释，所以不会将标签的内容显示到页面上。而那些新的浏览器将读懂这些脚本并执行它们，即使代码被嵌套在注释标签内：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">&lt;!-- </span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">"Hello World!"</span>) </span></span><br><span class="line"><span class="actionscript"><span class="comment">//--&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>支持script标签 的浏览器将显示script元素中的文本，不支持的则不会显示"Hello World!"。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="input输入"><a href="#input输入" class="headerlink" title="input输入"></a>input输入</h3><ul>
<li><strong>size与maxlength的关系</strong>：<br>size设定文本框的长度，对内容输入长度无限制，maxlength设定文本的最大输入长度。如果size的值小于maxlength的值，当内容超过窗口的长度时会自动滚动；如果size的值大于maxlength的值，超过maxlength长度的内容无法输入。</li>
<li>&lt;form target=”_blank&gt;，在&lt;input type=”submit”&gt;元素里输入target属性是无效的，应该用formtarget，并且formtarget属性会覆盖&lt;form&gt;元素的target属性。</li>
<li><strong>method中get和post的区别</strong>：<br>get：（1）是form默认的提交方式 ；（2）如果通过一个超链访问某个地址，是get方式 ；（3）如果在地址栏直接输入某个地址，是get方式 ；（4）提交数据会在浏览器显示出来 ，保密性差，所以不如post安全；（5）不可以用于提交二进制数据，比如上传文件 。<br>post：（1） 必须在form上通过method=”post” 显式指定 ；（2）提交数据不会在浏览器显示出来 ；（3）适合提交大量数据，可以用于提交二进制数据，比如上传文件。</li>
</ul>
<h3 id="音频、视频问题总结"><a href="#音频、视频问题总结" class="headerlink" title="音频、视频问题总结"></a>音频、视频问题总结</h3><ul>
<li><p>iPhone、iPad不能显示Flash视频。</p>
</li>
<li><p><strong>&lt;object&gt;和&lt;embed&gt;的区别</strong>：<br>（1）&lt;object&gt;标签是 HTML 4 的标准标签（在HTML 5中依然保留，但是删除了部分属性），&lt;embed&gt;标签是 HTML 5 的新标签，不支持HTML4（新生代，但是老版本的浏览器可能不认识它）；（2）功能上没有太大区别；（3）浏览器兼容性区别：IE只支持对Object的解析；火狐，谷歌，Safari只支持对Embed的解析；（4）格式上的区别：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">​<span class="tag">&lt;<span class="name">embed</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">src</span>=<span class="string">"/i/bookmark.swf"</span> /&gt;</span></span><br><span class="line">​<span class="tag">&lt;<span class="name">object</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">data</span>=<span class="string">"/i/bookmark.swf"</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;audio&gt;和&lt;video&gt;支持所有浏览器，不支持HTML4，在老式浏览器是无效的。</p>
</li>
<li><p><strong>音频最好的解决方法</strong>：<br>HTML 5 + &lt;object&gt; + &lt;embed&gt;（为什么添加两种格式的音频？因为使用了一个 mp3 文件，这样它在 Internet Explorer、Chrome 以及 Safari 中是有效的，为了使这段音频在 Firefox 和 Opera 中同样有效，添加了一个 ogg 类型的文件）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"/i/song.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"/i/song.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mp3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">data</span>=<span class="string">"/i/horse.mp3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">src</span>=<span class="string">"/i/song.mp3"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objiect</span>&gt;</span>​</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>音频最简单的解决方法</strong>：JavaScript嵌入雅虎播放器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/i/song.mp3"</span>&gt;</span>播放 mp3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"[http://mediaplayer.yahoo.com/js](http://mediaplayer.yahoo.com/js)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><strong>视频最好的解决方法</strong>：HTML 5 + &lt;object&gt; + &lt;embed&gt;。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.webm"</span> <span class="attr">type</span>=<span class="string">"video/webm"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">"movie.mp4"</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">"movie.swf"</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="output输出"><a href="#output输出" class="headerlink" title="output输出"></a>output输出</h3><ul>
<li><p>W3school上面的output例子不是特别好，应用比较复杂，可以参考下面这一个例子:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>在线计算器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">oninput</span>=<span class="string">"x.value=parseInt(a.value)+parseInt(b.value)"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span> + </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span> = </span><br><span class="line">    <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">"x"</span> <span class="attr">for</span>=<span class="string">"a b"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>注意:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> Edge 12及更早 IE 版本的浏览器不支持 output 元素。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>切图基础</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-变量的解构赋值</title>
    <url>/2020/06/17/ES6%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><ul>
<li>如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。<a id="more"></a>

</li>
</ul>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><ul>
<li>只有当一个数组成员严格等于undefined，默认值才会生效。下面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><ul>
<li>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</li>
<li>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure></li>
<li>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</li>
<li>）如果要将一个已经声明的变量用于解构赋值，必须非常小心。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure></li>
<li>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></li>
<li>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行</li>
</ul>
<h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><ul>
<li>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br></pre></td></tr></table></figure></li>
<li>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="圆括号的问题"><a href="#圆括号的问题" class="headerlink" title="圆括号的问题"></a>圆括号的问题</h3><h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><ul>
<li>变量声明语句<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure></li>
<li>函数参数<br>函数参数也属于变量声明，因此不能带有圆括号。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x</span>)]) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure></li>
<li>赋值语句的模式<br>下面代码将整个模式放在圆括号之中，导致报错。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><ul>
<li>可以使用圆括号的情况只有一种：<strong>赋值语句的非模式部分</strong>，可以使用圆括号。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
<li>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</li>
</ul>
<h3 id="变量的解构赋值用途"><a href="#变量的解构赋值用途" class="headerlink" title="变量的解构赋值用途"></a>变量的解构赋值用途</h3><ul>
<li>交换变量的值<br>下面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></li>
<li>从函数返回多个值<br>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure></li>
<li>函数参数的定义<br>解构赋值可以方便地将一组参数与变量名对应起来。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></li>
<li>提取 JSON 数据<br>解构赋值对提取 JSON 对象中的数据，尤其有用，下面代码可以快速提取 JSON 数据的值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure></li>
<li>函数参数的默认值<br>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>遍历 Map 结构<br>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure></li>
<li>输入模块的指定方法<br>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ES6学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-let和const</title>
    <url>/2020/06/17/ES6%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><ul>
<li>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<a id="more"></a></li>
<li>下面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure></li>
<li>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>
</ul>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><ul>
<li>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure></li>
<li>如果想将对象冻结，可以使用Object.freeze方法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><ul>
<li>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。<br>1.浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。<br>2.浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。<br>3.Node 里面，顶层对象是global，但其他环境都不支持。</li>
<li>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。<br>1.全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。<br>2.函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。<br>3.不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。</li>
</ul>
]]></content>
      <categories>
        <category>ES6学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>setTimeOut()和setInterval()讨论</title>
    <url>/2020/06/17/%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在学到setTimeOut()和setInterval()时，遇到这两个函数调用函数为什么不加括号的问题，以setTimeOut()为例，做了小测试，总结如下。</p>
<a id="more"></a>

<h4 id="当调用函数不加-时"><a href="#当调用函数不加-时" class="headerlink" title="当调用函数不加()时"></a>当调用函数不加()时</h4><ul>
<li>不加括号，网页会在3秒后弹出警告框，证明定时器起作用了。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">my</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"执行！"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    setTimeout(my, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="当调用函数加上-时"><a href="#当调用函数加上-时" class="headerlink" title="当调用函数加上()时"></a>当调用函数加上()时</h4><ul>
<li>加上括号，网页立即弹出警告框，证明定时器没起作用。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">my</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"执行！"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    setTimeout(my(), <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>使用定时器时，调度权没有在我们自己手里，而是定时器自己去间隔调用的。</li>
<li>加括号为调用该函数，返回值为函数返回值，而定时器是结合函数引用进行调度的，并不是函数的执行返回结果。</li>
<li>加括号时，可以加” “解决问题。</li>
</ul>
]]></content>
      <categories>
        <category>JS易混点&amp;难点</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝与深拷贝</title>
    <url>/2020/06/17/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h4 id="深拷贝和浅拷贝简单解释"><a href="#深拷贝和浅拷贝简单解释" class="headerlink" title="深拷贝和浅拷贝简单解释"></a>深拷贝和浅拷贝简单解释</h4><ul>
<li>浅拷贝和深拷贝都<strong>只针对于引用数据类型</strong>。</li>
<li>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</li>
<li>深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。<a id="more"></a>

</li>
</ul>
<h4 id="如何区分深拷贝与浅拷贝"><a href="#如何区分深拷贝与浅拷贝" class="headerlink" title="如何区分深拷贝与浅拷贝"></a>如何区分深拷贝与浅拷贝</h4><ul>
<li>简单点来说，假设B复制了A，当修改B时，看A是否会发生变化，如果A也跟着变了，说明这是浅拷贝，如果A没变，那就是深拷贝。</li>
</ul>
<h4 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h4><h5 id="直接用-赋值"><a href="#直接用-赋值" class="headerlink" title="直接用=赋值"></a>直接用=赋值</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[2, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[2, 2]</span></span><br></pre></td></tr></table></figure>

<h5 id="Object-assign方法"><a href="#Object-assign方法" class="headerlink" title="Object.assign方法"></a>Object.assign方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,[<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(a);</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[9, [2, 9]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[9, [2, 9]]</span></span><br></pre></td></tr></table></figure>

<h4 id="一层深拷贝的浅拷贝的实现"><a href="#一层深拷贝的浅拷贝的实现" class="headerlink" title="一层深拷贝的浅拷贝的实现"></a>一层深拷贝的浅拷贝的实现</h4><h5 id="扩展运算符方法"><a href="#扩展运算符方法" class="headerlink" title="扩展运算符方法"></a>扩展运算符方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = [...a];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[1, [2, 9]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[9, [2, 9]]</span></span><br></pre></td></tr></table></figure>

<h5 id="concat方法"><a href="#concat方法" class="headerlink" title="concat方法"></a>concat方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = a.concat();</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[1, [2, 9]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[9, [2, 9]]</span></span><br></pre></td></tr></table></figure>

<h5 id="slice方法"><a href="#slice方法" class="headerlink" title="slice方法"></a>slice方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = a.slice(<span class="number">0</span>);</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[1, [2, 9]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[9, [2, 9]]</span></span><br></pre></td></tr></table></figure>

<h5 id="Object-assign方法赋值给一个空对象"><a href="#Object-assign方法赋值给一个空对象" class="headerlink" title="Object.assign方法赋值给一个空对象"></a>Object.assign方法赋值给一个空对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,[<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign([], a);</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[1, [2, 9]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[9, [2, 9]]</span></span><br></pre></td></tr></table></figure>

<h4 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Array</span>.isArray(a) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">"object"</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.hasOwnProperty(i)) &#123;</span><br><span class="line">          <span class="comment">// 如果子属性为引用数据类型，递归复制</span></span><br><span class="line">          <span class="keyword">if</span> (a[i] &amp;&amp; <span class="keyword">typeof</span> a[i] === <span class="string">"object"</span>) &#123;</span><br><span class="line">            b[i] = deepCopy(a[i]);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是基本数据类型，只是简单的复制</span></span><br><span class="line">            b[i] = a[i];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = deepCopy(a);</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[1, [2, 3]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[9, [2, 9]]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS易混点&amp;难点</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-Symbol</title>
    <url>/2020/06/20/ES6%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（<code>Boolean</code>）、字符串（<code>String</code>）、数值（<code>Number</code>）、对象（<code>Object</code>）。</li>
<li>凡是属性名属于<code>Symbol</code>类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 <code>Symbol</code>实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol</code>函数的参数只是表示对当前 <code>Symbol</code> 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol</code> 值不能与其他类型的值进行运算，会报错。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">"your symbol is "</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol</code> 值可以显式转为字符串，也可以转为布尔值，但是不能转为数值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(sym) <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(sym) <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h3><ul>
<li>ES2019提供了一个实例属性<code>description</code>，直接返回 <code>Symbol</code> 的描述。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line">sym.description <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h3><ul>
<li>将对象的属性名指定为一个 <code>Symbol</code> 值，有以下3种方式。如果mySymbol不放在方括号中，该属性的键名就是字符串mySymbol，而不是mySymbol所代表的那个 <code>Symbol</code> 值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br><span class="line">a.mySymbol  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol</code> 值作为对象属性名时，不能用点运算符。下面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 <code>Symbol</code> 值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">'Hello!'</span>;</span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">'mySymbol'</span>] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h3><p>针对<code>Symbol</code>属性名，有两种遍历方式。</p>
<ul>
<li><code>Object.getOwnPropertySymbols()</code> 方法，可以获取指定对象的所有 <code>Symbol</code> 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 <code>Symbol</code> 值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure></li>
<li>一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 <code>Symbol</code> 键名。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"><span class="comment">//  ["enum", "nonEnum", Symbol(my_key)]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h3><ul>
<li><code>Symbol.for()</code>方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。如果有，就返回这个 <code>Symbol</code> 值，否则就新建一个以该字符串为名称的 <code>Symbol</code> 值，并将其注册到全局。</li>
<li>上面代码中，s1和s2都是 <code>Symbol</code> 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 <code>Symbol</code>。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 <code>Symbol</code> 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(“cat”) 30 次，每次都会返回同一个 <code>Symbol</code> 值，但是调用 <code>Symbol</code>(“cat”) 30 次，会返回 30 个不同的 <code>Symbol</code> 值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol.keyFor()</code>方法返回一个已登记的 <code>Symbol</code> 类型值的<code>key</code>。下面代码中，变量s2属于未登记的 <code>Symbol</code> 值，所以返回<code>undefined</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
<li>注意，<code>Symbol.for()</code>为 <code>Symbol</code> 值登记的名字，是全局环境的，不管有没有在全局环境运行。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = foo();</span><br><span class="line"><span class="keyword">const</span> y = <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x === y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h3><p>ES6 还提供了 11 个内置的 <code>Symbol</code> 值，指向语言内部使用的方法。（未完全列举）</p>
<h4 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h4><ul>
<li>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。</li>
<li>下面代码中，MyClass是一个类，new MyClass()会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.hasInstance](foo) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> MyClass() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h4><ul>
<li>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr1, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br><span class="line">arr1[<span class="built_in">Symbol</span>.isConcatSpreadable] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr2, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', ['c','d'], 'e']</span></span><br></pre></td></tr></table></figure></li>
<li>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</li>
<li>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'c'</span>, <span class="number">1</span>: <span class="string">'d'</span>&#125;;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', obj, 'e']</span></span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h4><ul>
<li>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</li>
<li>下面代码中，a.map(x =&gt; x)生成的衍生对象，就不是MyArray的实例，而直接就是<code>Array</code>的实例。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> MyArray();</span><br><span class="line"><span class="keyword">const</span> b = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> MyArray <span class="comment">// false</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h4><ul>
<li>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.match(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="built_in">Symbol</span>.match](<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMatcher</span> </span>&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.match](string) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span>.indexOf(string);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'e'</span>.match(<span class="keyword">new</span> MyMatcher()) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ES6学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-数据结构新增的方法</title>
    <url>/2020/06/20/ES6%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h3 id="字符串新增的方法"><a href="#字符串新增的方法" class="headerlink" title="字符串新增的方法"></a>字符串新增的方法</h3><h4 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h4><p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p>
<a id="more"></a>
<ul>
<li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li>
<li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line">s.startsWith(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'!'</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>这三个方法都支持第二个参数，表示开始搜索的位置。但是需要注意，使用第二个参数n时，<code>endsWith</code>的行为与其他两个方法有所不同，它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><ul>
<li><code>repeat()</code>方法返回一个新字符串，表示将原字符串重复n次。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span></span><br><span class="line"><span class="comment">//参数如果是小数，会被取整。</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>) <span class="comment">// "nana"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h4><ul>
<li>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</li>
<li>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="trimStart-，trimEnd"><a href="#trimStart-，trimEnd" class="headerlink" title="trimStart()，trimEnd()"></a>trimStart()，trimEnd()</h4><ul>
<li>这两个方法与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">'  abc  '</span>;</span><br><span class="line"></span><br><span class="line">s.trim() <span class="comment">// "abc"</span></span><br><span class="line">s.trimStart() <span class="comment">// "abc  "</span></span><br><span class="line">s.trimEnd() <span class="comment">// "  abc"</span></span><br></pre></td></tr></table></figure></li>
<li>除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</li>
</ul>
<h3 id="数值新增的方法"><a href="#数值新增的方法" class="headerlink" title="数值新增的方法"></a>数值新增的方法</h3><h4 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h4><ul>
<li><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite），即不是Infinity。<strong>注意，如果参数类型不是数值，<code>Number.isFinite</code>一律返回false。</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">15</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'foo'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'15'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li><code>Number.isNaN()</code>用来检查一个值是否为NaN。<strong>如果参数类型不是NaN，<code>Number.isNaN</code>一律返回false。</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span> / <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span> / <span class="string">'true'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><strong>与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于</strong>，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，<code>Number.isFinite()</code>对于非数值一律返回false, <code>Number.isNaN()</code>只有对于NaN才返回true，非NaN一律返回false。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">"25"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">"25"</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"NaN"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"NaN"</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><ul>
<li><code>Number.isInteger()</code>用来判断一个数值是否为整数。</li>
<li>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>如果参数不是数值，<code>Number.isInteger</code>返回false。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger() <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h4><ul>
<li><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-4.1</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-4.9</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-0.1234</span>) <span class="comment">// -0</span></span><br></pre></td></tr></table></figure></li>
<li>对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'123.456'</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">true</span>) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">null</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li>
<li>对于空值和无法截取整数的值，返回NaN。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">NaN</span>);      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'foo'</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc();         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数组新增的方法"><a href="#数组新增的方法" class="headerlink" title="数组新增的方法"></a>数组新增的方法</h3><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><ul>
<li>扩展运算符（spread）是三个点（…）,它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure></li>
<li>该运算符主要用于函数调用。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure></li>
<li>注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。下面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(...[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((...[<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="替代apply函数"><a href="#替代apply函数" class="headerlink" title="替代apply函数"></a>替代apply函数</h5><ul>
<li>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure></li>
<li>应用到<code>Math.max</code>方法，简化求出一个数组最大元素的写法。下面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用 <code>Math.max</code>函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用<code>Math.max</code>了。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure></li>
<li>通过<code>push</code>函数，将一个数组添加到另一个数组的尾部。下面代码的 ES5 写法中，<code>push</code>方法的参数不能是数组，所以只好通过<code>apply</code>方法变通使用<code>push</code>方法。有了扩展运算符，就可以直接将数组传入<code>push</code>方法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5的 写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h5><ul>
<li>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。下面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure></li>
<li>ES5 只能用变通方法来复制数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure></li>
<li>扩展运算符提供了复制数组的简便写法，下面的两种写法，a2都是a1的克隆。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h5><ul>
<li>扩展运算符提供了数组合并的新写法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="与解构赋值结合"><a href="#与解构赋值结合" class="headerlink" title="与解构赋值结合"></a>与解构赋值结合</h5><ul>
<li>扩展运算符可以与解构赋值结合起来，用于生成数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br></pre></td></tr></table></figure></li>
<li>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><ul>
<li>扩展运算符还可以将字符串转为真正的数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line"><span class="comment">// [ "h", "e", "l", "l", "o" ]</span></span><br></pre></td></tr></table></figure></li>
<li>下面代码的第一种写法，JavaScript 会将四个字节的 <code>Unicode</code> 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'x\uD83D\uDE80y'</span>.length <span class="comment">// 4</span></span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...str].length;</span><br><span class="line">&#125;</span><br><span class="line">length(<span class="string">'x\uD83D\uDE80y'</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="实现了-Iterator-接口的对象"><a href="#实现了-Iterator-接口的对象" class="headerlink" title="实现了 Iterator 接口的对象"></a>实现了 Iterator 接口的对象</h5><ul>
<li>任何定义了遍历器（<code>Iterator</code>）接口的对象，都可以用扩展运算符转为真正的数组。下面代码中，<code>querySelectorAll</code>方法返回的是一个<code>NodeList</code>对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了 <code>Iterator</code> 。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="Map-和-Set-结构，Generator-函数"><a href="#Map-和-Set-结构，Generator-函数" class="headerlink" title="Map 和 Set 结构，Generator 函数"></a>Map 和 Set 结构，Generator 函数</h5><ul>
<li>扩展运算符内部调用的是数据结构的 <code>Iterator</code> 接口，因此只要具有 <code>Iterator</code> 接口的对象，都可以使用扩展运算符，比如 <code>Map</code> 结构。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><ul>
<li><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（<code>array-like object</code>）和可遍历（<code>iterable</code>）的对象（包括 ES6 新增的数据结构 <code>Set</code> 和 <code>Map</code>）。下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><ul>
<li><code>Array.of</code>方法用于将一组值，转换为数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
<li>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。下面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find() 和 findIndex()"></a>find() 和 findIndex()</h4><ul>
<li>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure></li>
<li>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
<li>这两个方法都可以发现NaN，弥补了数组的<code>indexOf</code>方法的，下面代码中，<code>indexOf</code>方法无法识别数组的NaN成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><ul>
<li><code>fill</code>方法使用给定值，填充一个数组。数组中已有的元素，会被全部抹去。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure></li>
<li><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure></li>
<li>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123;<span class="attr">name</span>: <span class="string">"Mike"</span>&#125;);</span><br><span class="line">arr[<span class="number">0</span>].name = <span class="string">"Ben"</span>;</span><br><span class="line">arr</span><br><span class="line"><span class="comment">// [&#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="entries-，keys-和-values"><a href="#entries-，keys-和-values" class="headerlink" title="entries()，keys() 和 values()"></a>entries()，keys() 和 values()</h4><ul>
<li>用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br></pre></td></tr></table></figure></li>
<li>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="include"><a href="#include" class="headerlink" title="include()"></a>include()</h4><ul>
<li>返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。includes使用的是不一样的判断算法，就没有这个问题。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>严格相等运算符（===）的NaN不等于自身。</li>
</ul>
<h4 id="flat-，flatMap"><a href="#flat-，flatMap" class="headerlink" title="flat()，flatMap()"></a>flat()，flatMap()</h4><ul>
<li>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li>
<li><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</li>
<li><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组，只能展开一层数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h4><ul>
<li>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位，下面代码中，Array(3)返回一个具有 3 个空位的数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure></li>
<li>注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。下面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>ES5 对空位的处理，很不一致，大多数情况下会忽略空位。<br>1.<code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code>和<code>some()</code>都会跳过空位。<br>2.<code>map()</code>会跳过空位，但会保留这个值<br>3.<code>join()</code>和<code>toString()</code>会将空位视为undefined，而<code>undefined</code>和<code>null</code>会被处理成空字符串。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach方法</span></span><br><span class="line">[,<span class="string">'a'</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter方法</span></span><br><span class="line">[<span class="string">'a'</span>,,<span class="string">'b'</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// ['a','b']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every方法</span></span><br><span class="line">[,<span class="string">'a'</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce方法</span></span><br><span class="line">[<span class="number">1</span>,,<span class="number">2</span>].reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some方法</span></span><br><span class="line">[,<span class="string">'a'</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map方法</span></span><br><span class="line">[,<span class="string">'a'</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join方法</span></span><br><span class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">'#'</span>) <span class="comment">// "#a##"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString方法</span></span><br><span class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].toString() <span class="comment">// ",a,,"</span></span><br></pre></td></tr></table></figure></li>
<li><strong>ES6 则是明确将空位转为undefined。</strong></li>
</ul>
<h3 id="对象新增的方法"><a href="#对象新增的方法" class="headerlink" title="对象新增的方法"></a>对象新增的方法</h3><h4 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h4><ul>
<li>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure></li>
<li>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性，这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。<br>1.<code>for...in</code>：只遍历对象自身的和继承的可枚举的属性。<br>2.<code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。<br>3.<code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。<br>4.<code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>
<li>引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被for…in遍历到。下面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">'toString'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor([], <span class="string">'length'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><ul>
<li><strong>for…in</strong><br><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含<code>Symbol</code> 属性）。</li>
<li><strong>Object.keys(obj)</strong><br><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 <code>Symbol</code> 属性）的键名。</li>
<li><strong>Object.getOwnPropertyNames(obj)</strong><br><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含<code>Symbol</code>属性，但是包括不可枚举属性）的键名。</li>
<li><strong>Object.getOwnPropertySymbols(obj)</strong><br><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 <code>Symbol</code>属性的键名。</li>
<li><strong>Reflect.ownKeys(obj)</strong><br><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 <code>Symbol</code> 或字符串，也不管是否可枚举。</li>
<li>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。首先遍历所有数值键，按照数值升序排列。其次遍历所有字符串键，按照加入时间升序排列。最后遍历所有 <code>Symbol</code> 键，按照加入时间升序排列。</li>
</ul>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><ul>
<li><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。下面代码中，对象<code>obj.find()</code>方法之中，通过super.foo引用了原型对象proto的foo属性。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'world'</span>,</span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure></li>
<li>JavaScript 引擎内部，super.foo等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。下面代码中，super.foo指向原型对象proto的foo方法，但是绑定的<code>this</code>却还是当前对象obj，因此输出的就是world。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  x: <span class="string">'hello'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x: <span class="string">'world'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// "world"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><ul>
<li>用来比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>不同之处只有两个：<strong>一是+0不等于-0，二是NaN等于自身。</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><ul>
<li><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><ul>
<li><strong>浅拷贝</strong>，可详细参考<a href="https://starkmage.github.io/2020/06/17/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/#more" target="_blank" rel="noopener">浅拷贝与深拷贝</a>。</li>
<li><strong>同名属性的替换</strong>。对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加。下面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{ a: { b: ‘hello’, d: ‘e’ } }的结果。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span>, <span class="attr">d</span>: <span class="string">'e'</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: 'hello' &#125; &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>数组的处理</strong>。<code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。下面代码中，Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure></li>
<li><strong>取值函数的处理</strong>。Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。下面代码中，source对象的foo属性是一个取值函数，Object.assign不会复制这个取值函数，只会拿到值以后，将这个值复制过去。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">get</span> foo() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h4><ul>
<li>ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</li>
<li>下面代码中，<code>Object.getOwnPropertyDescriptors()</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> bar() &#123; <span class="keyword">return</span> <span class="string">'abc'</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><ul>
<li><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（<code>prototype</code>），返回参数对象本身，它是 ES6 正式推荐的设置原型对象的方法。</li>
<li>下面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><ul>
<li>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rec = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(rec, <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h4><ul>
<li>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（1enumerable`）属性的键名。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="comment">// ["foo", "baz"]</span></span><br></pre></td></tr></table></figure></li>
<li>ES2017 引入了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log([key, value]); <span class="comment">//[ ['a', 1], ['b', 2], ['c', 3] ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h4><ul>
<li><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">  [<span class="string">'baz'</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><ul>
<li>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li>
<li>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line">f(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br></pre></td></tr></table></figure></li>
<li>指定了默认值以后，函数的 <code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><ul>
<li>如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;)</span><br></pre></td></tr></table></figure></li>
<li><strong>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</strong></li>
</ul>
]]></content>
      <categories>
        <category>ES6学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-Set和Map</title>
    <url>/2020/06/20/ES6%E7%AC%94%E8%AE%B05/</url>
    <content><![CDATA[<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>ES6 提供了新的数据结构 <code>Set</code>，它类似于数组，但是成员的值都是唯一的，没有重复的值。<code>Set</code> 本身是一个构造函数，用来生成 <code>Set</code> 数据结构。<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure></li>
<li><code>Set</code>函数可以接受一个数组（或者具有 <code>iterable</code> 接口的其他数据结构）作为参数，用来初始化。注意，<code>Set</code>数据结构没有 <code>length</code>，用的是 <code>size</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...<span class="keyword">set</span>]</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);</span><br><span class="line">items.size // 5</span><br></pre></td></tr></table></figure></li>
<li><strong>向 <code>Set</code> 加入值的时候，不会发生类型转换</strong>，所以5和”5”是两个不同的值。<code>Set</code> 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），<strong>主要的区别是向 <code>Set</code> 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身</strong>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">let a = NaN;</span><br><span class="line">let b = NaN;</span><br><span class="line"><span class="keyword">set</span>.add(a);</span><br><span class="line"><span class="keyword">set</span>.add(b);</span><br><span class="line"><span class="keyword">set</span> // Set &#123;<span class="literal">NaN</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>两个对象总是不相等的。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;);</span><br><span class="line"><span class="keyword">set</span>.size // 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;);</span><br><span class="line"><span class="keyword">set</span>.size // 2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h6><ul>
<li><code>Set.prototype.add(value)</code>：添加某个值，返回 <code>Set</code> 结构本身。</li>
<li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.size <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.has(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="number">2</span>);</span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h6><ul>
<li><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象。由于 <code>Set</code> 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"></span><br><span class="line">for (let item of <span class="keyword">set</span>.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["red", "red"]</span></span><br><span class="line"><span class="comment">// ["green", "green"]</span></span><br><span class="line"><span class="comment">// ["blue", "blue"]</span></span><br></pre></td></tr></table></figure></li>
<li>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</li>
<li><code>Set</code> 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 <code>Set</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"></span><br><span class="line">for (let x of <span class="keyword">set</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure></li>
<li><code>Set</code> 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 4, 9]);</span><br><span class="line"><span class="keyword">set</span>.forEach((value, key) =&gt; console.log(key + ' : ' + value))</span><br><span class="line">// 1 : 1</span><br><span class="line">// 4 : 4</span><br><span class="line">// 9 : 9</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><h4 id="与Set区别"><a href="#与Set区别" class="headerlink" title="与Set区别"></a>与Set区别</h4><ul>
<li><code>WeakSet</code> 结构与 <code>Set</code> 类似，也是不重复的值的集合。但是，它与 <code>Set</code> 有两个区别。<br>1.<code>WeakSet</code> 的成员只能是对象，而不能是其他类型的值；<br>2.<code>WeakSet</code> 中的对象都是弱引用，即垃圾回收机制不考虑 <code>WeakSet</code> 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code>WeakSet</code> 之中。</li>
</ul>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li><code>WeakSet</code> 是一个构造函数，可以使用<code>new</code>命令，创建 <code>WeakSet</code> 数据结构。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br></pre></td></tr></table></figure></li>
<li>下面代码中，a是一个数组，它有两个成员，也都是数组。将a作为 <code>WeakSet</code> 构造函数的参数，a的成员会自动成为 <code>WeakSet</code> 的成员。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>注意，是a数组的成员成为 <code>WeakSet</code> 的成员，而不是a数组本身。这意味着，数组的成员只能是对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(b);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Invalid value used in weak set(…)</span></span><br></pre></td></tr></table></figure></li>
<li><code>WeakSet.prototype.add(value)</code>：向 <code>WeakSet</code> 实例添加一个新成员。</li>
<li><code>WeakSet.prototype.delete(value)</code>：清除 <code>WeakSet</code> 实例的指定成员。</li>
<li><code>WeakSet.prototype.has(value)</code>：返回一个布尔值，表示某个值是否在 <code>WeakSet</code> 实例之中。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.add(<span class="built_in">window</span>);</span><br><span class="line">ws.add(obj);</span><br><span class="line"></span><br><span class="line">ws.has(<span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">ws.has(foo);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">ws.delete(<span class="built_in">window</span>);</span><br><span class="line">ws.has(<span class="built_in">window</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li><code>WeakSet</code> 没有<code>size</code>属性，没有办法遍历它的成员。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.size <span class="comment">// undefined</span></span><br><span class="line">ws.forEach <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">ws.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'WeakSet has '</span> + item)&#125;)</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li><code>Map</code> 数据结构类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，<code>Object</code> 结构提供了“字符串—值”的对应，<code>Map</code> 结构提供了“值—值”的对应，是一种更完善的 <code>Hash</code> 结构实现。</li>
<li>作为构造函数，<code>Map</code> 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'name'</span>) <span class="comment">// "张三"</span></span><br><span class="line">map.has(<span class="string">'title'</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'title'</span>) <span class="comment">// "Author"</span></span><br></pre></td></tr></table></figure></li>
<li><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">items.forEach(</span><br><span class="line">  ([key, value]) =&gt; map.set(key, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>如果对同一个键多次赋值，后面的值将覆盖前面的值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(<span class="number">1</span>, <span class="string">'aaa'</span>)</span><br><span class="line">.set(<span class="number">1</span>, <span class="string">'bbb'</span>);</span><br><span class="line"></span><br><span class="line">map.get(<span class="number">1</span>) <span class="comment">// "bbb"</span></span><br></pre></td></tr></table></figure></li>
<li>只有对同一个对象的引用，<code>Map</code> 结构才将其视为同一个键。下面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">'a'</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
<li>同理，同样的值的两个实例，在 <code>Map</code> 结构中被视为两个键。下面代码中，变量k1和k2的值是一样的，但是它们在 <code>Map</code> 结构中被视为两个键。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, <span class="number">111</span>)</span><br><span class="line">.set(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">map.get(k1) <span class="comment">// 111</span></span><br><span class="line">map.get(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure></li>
<li>由上可知，<code>Map</code> 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</li>
</ul>
<h4 id="Map实例的属性和操作方法"><a href="#Map实例的属性和操作方法" class="headerlink" title="Map实例的属性和操作方法"></a>Map实例的属性和操作方法</h4><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><ul>
<li><code>size</code>属性返回 <code>Map</code> 结构的成员总数。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'foo'</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">'bar'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><h6 id="操作方法-1"><a href="#操作方法-1" class="headerlink" title="操作方法"></a>操作方法</h6><ul>
<li><code>Map.prototype.set(key, value)</code>，<code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 <code>Map</code> 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">'edition'</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">'standard'</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">'nah'</span>)    <span class="comment">// 键是 undefined</span></span><br></pre></td></tr></table></figure></li>
<li><code>set</code>方法返回的是当前的Map对象，因此可以采用链式写法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">'b'</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> n = m.set(<span class="string">"a"</span>, <span class="string">"asS"</span>);</span><br><span class="line">m.set(<span class="string">"b"</span>, <span class="string">"xsdcwc"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);  <span class="comment">//Map(2) &#123;"a" =&gt; "asS", "b" =&gt; "xsdcwc"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(n);  <span class="comment">//Map(2) &#123;"a" =&gt; "asS", "b" =&gt; "xsdcwc"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(m === n);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><code>Map.prototype.get(key)</code></li>
<li><code>Map.prototype.has(key)</code></li>
<li><code>Map.prototype.delete(key)</code>，<code>delete</code>方法删除某个键，返回<code>true</code>，如果删除失败，返回<code>false</code>。</li>
<li><code>Map.prototype.clear()</code>，没有返回值。</li>
</ul>
<h6 id="遍历方法-1"><a href="#遍历方法-1" class="headerlink" title="遍历方法"></a>遍历方法</h6><ul>
<li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li>
<li><code>Map.prototype.values()</code>：返回键值的遍历器。</li>
<li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li>
<li><code>Map.prototype.forEach()</code>：遍历 <code>Map</code> 的所有成员。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'F'</span>, <span class="string">'no'</span>],</span><br><span class="line">  [<span class="string">'T'</span>,  <span class="string">'yes'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F"</span></span><br><span class="line"><span class="comment">// "T"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "no"</span></span><br><span class="line"><span class="comment">// "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br></pre></td></tr></table></figure></li>
<li>上面代码最后的那个例子，表示 <code>Map</code> 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">map[<span class="built_in">Symbol</span>.iterator] === map.entries</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Map与其它数据结构转换"><a href="#Map与其它数据结构转换" class="headerlink" title="Map与其它数据结构转换"></a>Map与其它数据结构转换</h4><ul>
<li><code>Map</code> 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[...map.values()]</span><br><span class="line"><span class="comment">// ['one', 'two', 'three']</span></span><br><span class="line"></span><br><span class="line">[...map.entries()]</span><br><span class="line"><span class="comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span></span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line"><span class="comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span></span><br></pre></td></tr></table></figure></li>
<li>对象转为 Map 可以通过<code>Object.entries()</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure></li>
<li>如果所有 <code>Map</code> 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">'yes'</span>, <span class="literal">true</span>)</span><br><span class="line">  .set(<span class="string">'no'</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure></li>
<li>与<code>JSON</code>的转换，可以通过对象或者字符串为中介，进行转换。</li>
</ul>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><h4 id="与Map区别"><a href="#与Map区别" class="headerlink" title="与Map区别"></a>与Map区别</h4><ul>
<li>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</li>
<li>其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>
</ul>
<h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li>WeakMap只有四个方法可用：<code>get()、set()、has()、delete()</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// size、forEach、clear 方法都不存在</span></span><br><span class="line">wm.size <span class="comment">// undefined</span></span><br><span class="line">wm.forEach <span class="comment">// undefined</span></span><br><span class="line">wm.clear <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
<li>下面代码中，先新建一个 <code>Weakmap</code> 实例。然后，将一个 <code>DOM</code>节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 <code>WeakMap</code> 里面。这时，<code>WeakMap</code> 里面对element的引用就是弱引用，不会被计入垃圾回收机制。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">* <span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">'some information'</span>);</span><br><span class="line">wm.get(element) <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure></li>
<li>也就是说，上面的 <code>DOM</code> 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</li>
<li>注意，<code>WeakMap</code> 弱引用的只是键名，而不是键值。键值依然是正常引用。上面代码中，键值obj是正常引用。所以，即使在 <code>WeakMap</code> 外部消除了obj的引用，<code>WeakMap</code> 内部的引用依然存在。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.get(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><code>WeakMap</code> 应用的典型场合就是 <code>DOM</code> 节点作为键名。下面是一个例子。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>),</span><br><span class="line">  &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(<span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>));</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ES6学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES5与ES6继承的区别</title>
    <url>/2020/07/24/ES5%E4%B8%8EES6%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ol>
<li><p>ES5的继承实质上是先创建子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上（<code>Parent.apply(this)</code>）。</p>
<a id="more"></a></li>
<li><p>ES6的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>
</li>
<li><p>ES5的继承时通过原型或构造函数机制来实现。</p>
</li>
<li><p>ES6通过<code>class</code>关键字定义类，里面有构造方法，类之间通过<code>extends</code>关键字实现继承。子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例报错。因为子类没有自己的<code>this</code>对象，而是继承了父类的<code>this</code>对象，然后对其进行加工。如果不调用<code>super</code>方法，子类得不到<code>this</code>对象。</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/23609865-b4b4819a4b32947f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/23609865-4c0977619082923a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
      <categories>
        <category>JS易混点&amp;难点</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-Class总结</title>
    <url>/2020/07/24/ES6%E4%B8%AD%E7%9A%84class/</url>
    <content><![CDATA[<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>ES6 的类，完全可以看作构造函数的另一种写法。下面代码表明，类的数据类型就是函数，类本身就指向构造函数。<a id="more"></a>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义“类”的方法的时候，前面<strong>不需要加上<code>function</code>这个关键字</strong>，直接把函数定义放进去了就可以了。另外，<strong>方法之间不需要逗号分隔</strong>，加了会报错。</p>
</li>
<li><p>类的所有方法都定义在类的<code>prototype</code>属性上面。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在类的实例上面调用方法，其实就是调用原型上的方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>prototype</code>对象的<code>constructor</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Point.prototype.constructor === Point <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>类的内部所有定义的方法，都是不可枚举的（<code>non-enumerable</code>），这与ES5是不完全一致的。</p>
</li>
<li><p><code>Class</code>不存在提升。</p>
</li>
</ul>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul>
<li>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 <code>static</code> 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。下面代码中，静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> bar() &#123;</span><br><span class="line">    <span class="keyword">this</span>.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> baz() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  baz() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<ul>
<li>父类的静态方法，可以被子类继承。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>

<h4 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h4><ul>
<li>属性也可以定义在类的最顶层，其他都不变。下面代码中，实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级，<strong>这时，不需要在实例属性前面加上<code>this</code></strong>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Getting the current value!'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="keyword">this</span>._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</li>
</ul>
<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><ul>
<li>静态属性指的是 <code>Class</code> 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。下面的写法为<code>Foo</code>类定义了一个静态属性<code>prop</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</li>
</ul>
<h4 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h4><ul>
<li><p><strong>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</strong></p>
</li>
<li><p><code>Class</code> 可以通过<code>extends</code>关键字实现继承。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><h5 id="作为函数使用"><a href="#作为函数使用" class="headerlink" title="作为函数使用"></a>作为函数使用</h5><ul>
<li><p><code>super</code>作为函数调用时，代表父类的构造函数。</p>
</li>
<li><p>注意，<code>super</code>虽然代表了父类A的构造函数，但是返回的是子类B的实例，即<code>super</code>内部的<code>this</code>指的是B的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B() <span class="comment">// B</span></span><br></pre></td></tr></table></figure>

<ul>
<li>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="作为对象使用"><a href="#作为对象使用" class="headerlink" title="作为对象使用"></a>作为对象使用</h5><ul>
<li><p><strong>在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</strong></p>
</li>
<li><p>下面代码中，子类B当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  p() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.p()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。下面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是<code>super.print.call(this)</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。下面代码中，<code>super.x</code>赋值为3，这时等同于对<code>this.x</code>赋值为3。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">super</span>.x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.x); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>

<ul>
<li>下面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myMethod(msg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'static'</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'instance'</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myMethod(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line">child.myMethod(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。下面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法，这个方法里面的<code>this</code>指向的是B，而不是B的实例。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.x = <span class="number">3</span>;  <span class="comment">//静态属性</span></span><br><span class="line">B.m() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h4 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和__proto__属性"></a>类的 <code>prototype</code> 属性和<code>__proto__</code>属性</h4><ul>
<li><p><code>Class</code> 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>
</li>
<li><p>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p>
</li>
<li><p>子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A <span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，子类B的<code>__proto__</code>属性指向父类A，子类B的<code>prototype</code>属性的<code>__proto__</code>属性指向父类A的<code>prototype</code>属性。这样的结果是因为，类的继承是按照下面的模式实现的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 的实例继承 A 的实例</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 继承 A 的静态属性</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B, A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ES6学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的数组迭代方法中的一些问题</title>
    <url>/2020/07/24/JS%E4%B8%AD%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>看一个例子。</p>
<a id="more"></a>
<p>利用<code>forEach</code>对一个数组进行迭代，其中数组的下标2位置未设置值，<code>forEach</code>对空数组位置<code>empty</code>是不会执行迭代的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array1 = [<span class="string">"a"</span>, <span class="string">"b"</span>, , <span class="string">"d"</span>];</span><br><span class="line"></span><br><span class="line">array1.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value + <span class="string">"    "</span> + index);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a  0</span></span><br><span class="line"><span class="comment">b  1</span></span><br><span class="line"><span class="comment">c  3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1);</span><br><span class="line"><span class="comment">//["a", "b", empty, "d"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">2</span>] === <span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">2</span>] === empty)</span><br><span class="line"><span class="comment">//报错！ReferenceError: empty is not defined</span></span><br></pre></td></tr></table></figure>


<p>而看下面这种情况，这时对<code>undefined</code>执行了迭代。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array2 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="literal">undefined</span>, <span class="string">"d"</span>];</span><br><span class="line"></span><br><span class="line">array2.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value + <span class="string">"    "</span> + index);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a  0</span></span><br><span class="line"><span class="comment">b  1</span></span><br><span class="line"><span class="comment">undefined  2</span></span><br><span class="line"><span class="comment">c  3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(array2);</span><br><span class="line"><span class="comment">//["a", "b", undefined, "d"]</span></span><br></pre></td></tr></table></figure>

<p>利用<code>for..in</code>迭代也会出现与<code>forEch</code>一样的情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array1 = [<span class="string">"a"</span>, <span class="string">"b"</span>, , <span class="string">"d"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> array1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index + <span class="string">"    "</span> + array1[i]);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0    a</span></span><br><span class="line"><span class="comment">1    b</span></span><br><span class="line"><span class="comment">3    d</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>而用<code>for...of</code>迭代则会对所有元素进行迭代。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array1 = [<span class="string">"a"</span>, <span class="string">"b"</span>, , <span class="string">"d"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> array1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">undefined</span></span><br><span class="line"><span class="comment">d</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>一个小例子</p>
<pre><code class="JS"><span class="keyword">let</span> array = <span class="built_in">Array</span>(<span class="number">9</span>);
<span class="built_in">console</span>.log(array);
<span class="comment">//empty*9</span>
<span class="built_in">console</span>.log([...array]);
<span class="comment">//undefined,....,undefined</span></code></pre>
]]></content>
      <categories>
        <category>JS易混点&amp;难点</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的prototype、__proto__与constructor</title>
    <url>/2020/07/24/JS%E4%B8%AD%E7%9A%84prototype%E3%80%81__proto__%E4%B8%8Econstructor/</url>
    <content><![CDATA[<p>先说总结：</p>
<ol>
<li><p><code>__proto__</code>和<code>constructor</code>属性是对象所独有的；</p>
<a id="more"></a>
<p><code>prototype</code>属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性。</p>
</li>
<li><p><code>__proto__</code>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（父对象）里找，一直找，直到<code>__proto__</code>属性的终点<code>null</code>，再往上找就相当于在<code>null</code>上取值，会报错。通过<code>__proto__</code>属性将对象连接起来的这条链路即我们所谓的原型链。</p>
</li>
<li><p><code>prototype</code>属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即<code>f1.__proto__</code> === <code>Foo.prototype</code>。</p>
</li>
<li><p><code>constructor</code>属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向<code>Function</code>。</p>
</li>
</ol>
<p>用一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>

<h4 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a><code>__proto__</code>属性</h4><ul>
<li><p><code>__proto__</code>属性都是<strong>由一个对象指向一个对象</strong>，即指向它们的原型对象（也可以理解为父对象）。</p>
</li>
<li><p>那么这个属性的作用是什么呢？<br>它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的<code>__proto__</code>属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端nul，再往上找就相当于在null上取值，会报错（找不到了，到此结束，null为原型链的终点），由以上这种通过<code>__proto__</code>属性来连接对象直到null的一条链即为我们所谓的原型链。</p>
</li>
<li><p>我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠<code>__proto__</code>继承而来的。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/23609865-10103b36360d523b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a><code>prototype</code>属性</h4><ul>
<li><p><strong>函数独有的，从一个函数指向一个对象</strong>。</p>
</li>
<li><p>它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象，由此可知：<code>f1.__proto__ === Foo.prototype</code>，它们两个完全一样。</p>
</li>
<li><p><code>prototype</code>属性的作用又是什么呢？<br>它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法，任何函数在创建的时候，其实会默认同时创建该函数的<code>prototype</code>对象。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/23609865-1fc3cb1c604a236c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a><code>constructor</code>属性</h4><ul>
<li><p><strong>从一个对象指向一个函数</strong>。</p>
</li>
<li><p>含义就是指向该对象的构造函数。每个对象都可以找到其对应的<code>constructor</code>，因为创建对象的前提是需要有<code>constructor</code>，而这个<code>constructor</code>可能是对象自己本身显式定义的或者通过<code>__proto__</code>在原型链中找到的。<strong>而单从<code>constructor</code>这个属性来讲，只有<code>prototype</code>对象才有。</strong>每个函数在创建的时候，js会同时创建一个该函数对应的<code>prototype</code>对象，而<code>f1.__proto__ === Foo.prototype</code>，<code>Foo.prototype.constructor === Foo</code>，故通过函数创建的对象即使自己没有<code>constructor</code>属性，它也能通过<code>__proto__</code>找到对应的<code>constructor</code>，所以任何对象最终都可以找到其构造函数（<code>nul</code>l如果当成对象的话，将<code>null</code>除外）。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/23609865-2e227a1e50a438a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>————————————————<br>参考文章：<a href="https://blog.csdn.net/cc18868876837/java/article/details/81211729" target="_blank" rel="noopener">https://blog.csdn.net/cc18868876837/java/article/details/81211729</a></p>
]]></content>
      <categories>
        <category>JS易混点&amp;难点</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的new操作符</title>
    <url>/2020/07/24/JS%E7%9A%84new%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h4><p>1、创建一个空的对象；</p>
<p>2、链接到原型对象；</p>
<a id="more"></a>

<p>3、绑定this指向，执行构造函数；</p>
<p>4、确保返回的是对象 。</p>
<h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><p>给出一个场景</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> People();</span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个空对象;</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure>

<p>2、设置原型链（当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象）;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj._proto_ = People.prototype;</span><br></pre></td></tr></table></figure>

<p>3、让<code>People</code>中的<code>this</code>指向<code>obj</code>，并执行<code>People</code>的函数体。（创建新的对象之后，将构造函数的作用域赋给实例（因此<code>this</code>就指向了这个实例））</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = People.call(obj);</span><br></pre></td></tr></table></figure>

<p>4、判断函数的返回值类型：</p>
<p>  如果是值类型，返回<code>obj</code>。如果是引用类型，就返回这个引用类型的对象。</p>
<p>（1）如果没有写<code>return</code>，相当于<code>return undefined</code>，JS中的函数都是这样。<code>undefined</code>是值类型的，因此丢弃它，返回<code>obj</code>。（2）如果<code>return this</code>相当于返回一个引用类型的对象，它自己就是<code>obj</code>，无所谓替换不替换了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">"object"</span>)&#123;</span><br><span class="line">  p = result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  p = obj;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS易混点&amp;难点</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的类方法、对象方法、原型方法</title>
    <url>/2020/07/24/JavaScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%96%B9%E6%B3%95%E3%80%81%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E3%80%81%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li><p>类方法：也叫函数方法，在JavaScript中函数也是一个对象，所以可以为函数添加属性以及方法；</p>
<a id="more"></a></li>
<li><p>对象方法：也叫实例方法，包括构造函数中的方法以及其原型上面的方法；</p>
</li>
<li><p>原型方法：一般用于对象实例共享，在原型上面添加该方法，就能实现共享。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.name=name; </span><br><span class="line">  <span class="comment">//对象方法 (实例方法)</span></span><br><span class="line">  <span class="comment">//每个对象实例都有的方法</span></span><br><span class="line">  <span class="comment">//只有对象实例才能调用的方法</span></span><br><span class="line">  <span class="keyword">this</span>.speak=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"你好，我的名字是"</span>+<span class="keyword">this</span>.name); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//类方法 </span></span><br><span class="line"><span class="comment">//只有原型才能调用的方法</span></span><br><span class="line">People.sex=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"男，女"</span>)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//原型方法 </span></span><br><span class="line"><span class="comment">//所有对象实例共享的方法</span></span><br><span class="line"><span class="comment">//原型可通过People.prototype.growUp()调用</span></span><br><span class="line">People.prototype.growUp=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"人是不断成长的"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> People(<span class="string">"张三"</span>); </span><br><span class="line">p.speak();        <span class="comment">//对象方法需要通过实例化对象去调用 </span></span><br><span class="line">People.sex();        <span class="comment">//类方法不需要通过实例化对象去调用 </span></span><br><span class="line">p.growUp();   <span class="comment">//原型方法也需要通过实例化对象去调用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>写在原型中的方法可以被所有的实例共享， 实例化的时候不会在实例内存中再复制一份，占有的内存消耗少。</p>
</li>
<li><p>每个原型对象都属于对象，所以它也有自己的原型，而它自己的原型对象又有自己的原型，所以就形成了原型链。</p>
</li>
<li><p>一个对象的隐式原型指向构造这个对象的构造函数的显式原型，所以这个对象可以访问构造函数的属性和方法（new一个实例）。</p>
</li>
<li><p>JavaScript的继承也就是通过原型链来实现的，当访问一个对象的属性，如果这个对象本身不存在，则沿着<code>__proto__</code>依次往上查找，如果有则返回值，没有则一直到查到<code>Object.prototype</code>的<code>__proto__</code>的值为<code>null</code>.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS易混点&amp;难点</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>flex布局常用语法</title>
    <url>/2020/07/24/flex%E5%B8%83%E5%B1%80%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li><p>轴</p>
<ul>
<li><p>主轴main axis</p>
<ul>
<li><p>main start</p>
</li>
<li><p>main end</p>
</li>
<li><p>main size</p>
<a id="more"></a>
</li>
</ul>
</li>
<li><p>纵轴cross axis</p>
<ul>
<li><p>cross start</p>
</li>
<li><p>cross end</p>
</li>
<li><p>cross size</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>容器的属性</p>
<ul>
<li><p>flex-direction——决定主轴的方向（即项目的排列方向）</p>
<ul>
<li><p>row（默认值）：主轴为水平方向，起点在左端</p>
</li>
<li><p>row-reverse：主轴为水平方向，起点在右端</p>
</li>
<li><p>column：主轴为垂直方向，起点在上沿</p>
</li>
<li><p>column-reverse：主轴为垂直方向，起点在下沿</p>
</li>
</ul>
</li>
<li><p>flex-wrap——定义如果一条轴线排不下，如何换行</p>
<ul>
<li><p>nowrap（默认）：不换行</p>
</li>
<li><p>wrap：换行，第一行在上方</p>
</li>
<li><p>wrap-reverse：换行，第一行在下方</p>
</li>
</ul>
</li>
<li><p>flex-flow</p>
<ul>
<li>flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</li>
</ul>
</li>
<li><p>justify-content——定义了项目在主轴上的对齐方式</p>
<ul>
<li><p>flex-start（默认值）：左对齐</p>
</li>
<li><p>flex-end：右对齐</p>
</li>
<li><p>center： 居中</p>
</li>
<li><p>space-between：两端对齐，项目之间的间隔都相等</p>
</li>
<li><p>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</p>
</li>
</ul>
</li>
<li><p>align-items——定义项目在交叉轴上如何对齐</p>
<ul>
<li><p>flex-start：交叉轴的起点对齐。</p>
</li>
<li><p>flex-end：交叉轴的终点对齐。</p>
</li>
<li><p>center：交叉轴的中点对齐。</p>
</li>
<li><p>baseline: 项目的第一行文字的基线对齐。</p>
</li>
<li><p>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</p>
</li>
</ul>
</li>
<li><p>align-content——定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p>
<ul>
<li><p>flex-start：与交叉轴的起点对齐</p>
</li>
<li><p>flex-end：与交叉轴的终点对齐</p>
</li>
<li><p>center：与交叉轴的中点对齐</p>
</li>
<li><p>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布</p>
</li>
<li><p>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</p>
</li>
<li><p>stretch（默认值）：轴线占满整个交叉轴</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>项目的属性</p>
<ul>
<li><p>order</p>
<ul>
<li><p>定义项目的排列顺序</p>
</li>
<li><p>数值越小，排列越靠前，默认为0</p>
</li>
</ul>
</li>
<li><p>flex-grow</p>
<ul>
<li><p>定义项目的放大比例</p>
</li>
<li><p>默认为0，即如果存在剩余空间，也不放大</p>
</li>
<li><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）</p>
</li>
<li><p>如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍</p>
</li>
</ul>
</li>
<li><p>flex-shrink</p>
<ul>
<li><p>定义了项目的缩小比例</p>
</li>
<li><p>默认为1，即如果空间不足，该项目将缩小</p>
</li>
<li><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小</p>
</li>
<li><p>如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小</p>
</li>
</ul>
</li>
<li><p>flex-basis</p>
<ul>
<li><p>定义了在分配多余空间之前，项目占据的主轴空间（main size）</p>
</li>
<li><p>浏览器根据这个属性，计算主轴是否有多余空间</p>
</li>
<li><p>它的默认值为auto，即项目的本来大小</p>
</li>
<li><p>可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间</p>
</li>
</ul>
</li>
<li><p>flex</p>
<ul>
<li><p>flex-grow, flex-shrink 和 flex-basis的简写</p>
</li>
<li><p>默认值为0 1 auto，后两个属性可选</p>
</li>
<li><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)</p>
</li>
<li><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</p>
</li>
</ul>
</li>
<li><p>align-self</p>
<ul>
<li><p>允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性</p>
</li>
<li><p>默认值为auto，表示继承父元素的align-items属性</p>
</li>
<li><p>如果没有父元素，则等同于stretch</p>
</li>
<li><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>切图基础</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>搞懂JS中的this指向</title>
    <url>/2020/07/24/this%E6%8C%87%E5%90%91case%EF%BC%88%E6%8C%81%E7%BB%AD%E8%A1%A5%E5%85%85%EF%BC%89/</url>
    <content><![CDATA[<p>文字是苍白的，直接看case理解。</p>
<a id="more"></a>

<h4 id="setTimeout相关例子"><a href="#setTimeout相关例子" class="headerlink" title="setTimeout相关例子"></a>setTimeout相关例子</h4><p>箭头函数里的this指向，一层层向外查找，直到有this的定义。箭头函数this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。</p>
<ul>
<li>把foo函数内的this指向为{id :3}，非箭头延时函数是Window调用的，所以它的this指向Window。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">100</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">2</span>;</span><br><span class="line">foo.call(&#123;<span class="attr">id</span>: <span class="number">3</span>&#125;);</span><br><span class="line"><span class="comment">//&#123;id: 3&#125;,  3</span></span><br><span class="line"><span class="comment">//Window,  2</span></span><br><span class="line"><span class="comment">//&#123;id: 3&#125;,  3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>foo函数内id不声明直接赋值的话，相当于把Window上声明的id重新赋值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">100</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">2</span>;</span><br><span class="line">foo.call(&#123;<span class="attr">id</span>: <span class="number">3</span>&#125;);</span><br><span class="line"><span class="comment">//&#123;id: 3&#125;,  3</span></span><br><span class="line"><span class="comment">//Window,  1</span></span><br><span class="line"><span class="comment">//&#123;id: 3&#125;,  3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>把foo函数内的this指向为Window。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">100</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">2</span>;</span><br><span class="line">foo.call();</span><br><span class="line"><span class="comment">//Window,  2</span></span><br><span class="line"><span class="comment">//Window,  2</span></span><br><span class="line"><span class="comment">//Window,  2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>window调用的foo函数，所以foo内this指向Window。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">100</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">2</span>;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">//Window,  2</span></span><br><span class="line"><span class="comment">//Window,  2</span></span><br><span class="line"><span class="comment">//Window,  2</span></span><br></pre></td></tr></table></figure>

<h4 id="对象相关"><a href="#对象相关" class="headerlink" title="对象相关"></a>对象相关</h4><ul>
<li>因为对象是不构成作用域的，所以箭头函数指向为Window，而普通函数的this指向调用它的p对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = &#123;</span><br><span class="line">    age: <span class="number">19</span>,</span><br><span class="line">    sayAge1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;,</span><br><span class="line">    sayAge2: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">p.sayAge1();</span><br><span class="line">p.sayAge2();</span><br><span class="line"><span class="comment">//p对象，19</span></span><br><span class="line"><span class="comment">//Window，20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用let声明的变量，不属于Window作用域，属于它的作用域，下例中的let声明变量属于script的作用域。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = &#123;</span><br><span class="line">    age: <span class="number">19</span>,</span><br><span class="line">    sayAge1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;,</span><br><span class="line">    sayAge2: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line">p.sayAge1();</span><br><span class="line">p.sayAge2();</span><br><span class="line"><span class="comment">//p对象，19</span></span><br><span class="line"><span class="comment">//Window，undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="对象与延时函数结合"><a href="#对象与延时函数结合" class="headerlink" title="对象与延时函数结合"></a>对象与延时函数结合</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"对象"</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo();</span><br><span class="line"><span class="comment">//obj对象，&#123;name: "对象", foo: ƒ&#125;</span></span><br><span class="line"><span class="comment">//Window</span></span><br><span class="line"><span class="comment">//obj对象，&#123;name: "对象", foo: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"对象"</span>,</span><br><span class="line">    foo: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo();</span><br><span class="line"><span class="comment">//Window</span></span><br><span class="line"><span class="comment">//Window</span></span><br><span class="line"><span class="comment">//Window</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"对象"</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo();</span><br><span class="line"><span class="comment">//Window</span></span><br><span class="line"><span class="comment">//Window</span></span><br><span class="line"><span class="comment">//Window</span></span><br><span class="line"><span class="comment">//obj对象，&#123;name: "对象", foo: ƒ&#125;</span></span><br></pre></td></tr></table></figure>


<h4 id="构造函数相关"><a href="#构造函数相关" class="headerlink" title="构造函数相关"></a>构造函数相关</h4><ul>
<li>经过new操作符后，People内的this指向为p。</li>
</ul>
<pre><code class="JS"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">age</span>) </span>{
    <span class="keyword">this</span>.age = age;
    <span class="keyword">this</span>.sayAge1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.age);
    };
    <span class="keyword">this</span>.sayAge2 = <span class="function"><span class="params">()</span> =&gt;</span> {
        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.age);
    }
}

<span class="keyword">let</span> p = <span class="keyword">new</span> People(<span class="number">20</span>);
p.sayAge1();
p.sayAge2();
<span class="comment">//People {age: 20, sayAge1: ƒ, sayAge2: ƒ} 20</span>
<span class="comment">//People {age: 20, sayAge1: ƒ, sayAge2: ƒ} 20</span></code></pre>
]]></content>
      <categories>
        <category>JS易混点&amp;难点</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JS异步-宏队列与微队列</title>
    <url>/2020/07/24/JS%E5%BC%82%E6%AD%A5-%E5%AE%8F%E9%98%9F%E5%88%97%E4%B8%8E%E5%BE%AE%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>首先说一下引擎和runtime的区别</p>
<ul>
<li><p>引擎：解释并编译代码，让它变成能交给机器运行的代码（runnable commands）。</p>
<a id="more"></a>
</li>
<li><p>runtime：就是运行环境，它提供一些对外接口供js调用，以跟外界打交道，比如，浏览器环境、Node.js环境。不同的runtime，会提供不同的接口，比如，在 Node.js 环境中，我们可以通过 require 来引入模块；而在浏览器中，我们有 window、 DOM。</p>
</li>
<li><p>Js引擎是单线程的，如下图中，它负责维护任务队列，并通过 Event Loop 的机制，按顺序把任务放入栈中执行。而图中的异步处理模块，就是 runtime 提供的，拥有和Js引擎互不干扰的线程。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/23609865-38080ff3739f6104.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>用一段代码完全搞清楚这个过程</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//timeout1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//timeout2</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'5'</span>);</span><br><span class="line">            resolve()<span class="comment">//promise1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>);</span><br><span class="line">    resolve();<span class="comment">//promise2</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//timeout3</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>);</span><br><span class="line">        resolve();<span class="comment">//promise3</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'13'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//timeout4</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'14'</span>)</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'15'</span>)</span><br><span class="line">            resolve() <span class="comment">//promise4</span></span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'16'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>在浏览器环境，出队一个任务，并执行</strong></p>
<p>先说结果：1，8，9，2，4，10，12，13，5，6，14，15，16</p>
<p>第一次执行代码：输出1，timeout1压入宏队列，输出8,promise2压入微队列，timeout3压入宏任务队列。</p>
<p>//在浏览器端，边执行代码，边把异步代码加入对应队列，这一次执行都是同步代码。</p>
<p>//宏任务队列内[timeout1,timeout3]，微任务队列[promise2]</p>
<p>第二次执行代码（promise2出队）：输出9</p>
<p>//微任务队列优先级高，先执行微任务，浏览器端只有一个任务出队并执行。</p>
<p>//宏任务队列内[timeout1,timeout3]，微任务队列[]</p>
<p>第三次执行代码（timeout1出队）：输出2，输出4，timeout2压入宏队。</p>
<p>//宏任务队列内[timeout3,timeout2]，微任务队列[]</p>
<p>第四次执行代码（timeout3出队）：输出10，输出12，promise3压入微队列，timeout4压入宏队列。</p>
<p>//宏任务队列内[timeout2,timeout4]，微任务队列[promise3]</p>
<p>第五次执行代码（promise3出队）：输出13。</p>
<p>//宏任务队列内[timeout2,timeout4]，微任务队列[]</p>
<p>第六次执行代码（timeout2出队）：输出5，promise1压入微队列。</p>
<p>//宏任务队列内[timeout4]，微任务队列[promise1]</p>
<p>第七次执行代码（promise1出队）：输出6。</p>
<p>//宏任务队列内[timeout4]，微任务队列[]</p>
<p>第八次执行代码（timeout4出队）：输出14，输出15，promise4压入微队列。</p>
<p>//宏任务队列内[]，微任务队列[promise4]</p>
<p>第九次执行代码（promise4出队）：输出16。</p>
<p>//宏任务队列内[]，微任务队列[]</p>
<p><strong>node环境中，任务全部出队，并执行</strong></p>
<p>先说结果：1，8，9，2，4，10，12，13，5，14，15，6，16</p>
<p>第一次执行代码：输出1，timeout1压入宏队列，输出8,promise2压入微队列，timeout3压入宏任务队列。</p>
<p>//第一次执行node端和浏览器端二者相同。</p>
<p>//宏任务队列内[timeout1,timeout3]，微任务队列[promise2]</p>
<p>第二次执行代码（promise2出队）：输出9</p>
<p>//二者相同。</p>
<p>//宏任务队列内[timeout1,timeout3]，微任务队列[]</p>
<p>第三次执行代码（[timeout1,timeout3出队）：输出2，输出4，timeout2压入宏队列，输出10，输出12，promise3压入微队列，timeout4压入宏队列。</p>
<p>//这里我们可以看到，node与浏览器不同之处，timeout1,timeout3一起出队，所以内部的同等级（同步代码）就一起执行了。node环境的这一次执行完成了浏览器多次执行步骤。</p>
<p>//宏任务队列内[timeout2,timeout4]，微任务队列[promise3]</p>
<p>第四次执行代码（promise3出队）：输出13。</p>
<p>//宏任务队列内[timeout2,timeout4]，微任务队列[]</p>
<p>第五次执行代码（timeout2,timeout4出队）：输出5，promise1压入微队列，输出14，输出15，promise4压入微队列。</p>
<p>//在这里输出数值与浏览器端开始有差异。</p>
<p>//宏任务队列内[]，微任务队列[promise1,promise4]</p>
<p>第六次执行代码（promise1,promise4出队）：输出6，输出16。</p>
<p>//宏任务队列内[]，微任务队列[]</p>
<p><strong>总结：</strong></p>
<p>简单结构的代码，一般执行顺序：同步-&gt;微任务-&gt;宏任务。复杂结构代码，微任务优先级大于宏任务优先级。</p>
<p>同步代码边执行，边把异步任务入队，然后系统选择出队的任务再一次新一轮执行。</p>
<p><strong>补充：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">            resolve(<span class="number">6</span>)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">    p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 3 7 4 1 2 5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"0"</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;        </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"3"</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;      </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"4"</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;       </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"5"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"6"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"7"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;         </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"8"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//1, 7, 2, 3, 8, 4, 6, 5, 0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Promise专辑</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise的使用方法</title>
    <url>/2020/07/24/Promise%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="函数对象与实例对象"><a href="#函数对象与实例对象" class="headerlink" title="函数对象与实例对象"></a>函数对象与实例对象</h4><ul>
<li>函数对象：将函数作为对象使用时, 简称为函数对象。<a id="more"></a></li>
<li>实例对象：new 函数产生的对象, 简称为对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="keyword">new</span> Fn();  <span class="comment">//fn是实例对象，Fn是构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype);  <span class="comment">//Fn是函数对象</span></span><br><span class="line">Fn.call(&#123;&#125;);  <span class="comment">//Fn是函数对象</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="回调函数的分类"><a href="#回调函数的分类" class="headerlink" title="回调函数的分类"></a>回调函数的分类</h4><h5 id="同步回调"><a href="#同步回调" class="headerlink" title="同步回调"></a>同步回调</h5><ul>
<li>理解：立即执行, 完全执行完了才结束, 不会放入回调队列中。</li>
<li>例子：数组遍历相关的回调函数、Promise的excutor函数。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">    arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span>&#123;  <span class="comment">//遍历回调</span></span><br><span class="line">      <span class="built_in">console</span>.log(item);</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"forEach之后"</span>);</span><br><span class="line"><span class="comment">//打印顺序：1, 3, 5, forEach之后</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h5><ul>
<li>理解：不会立即执行, 会放入回调队列中将来执行。</li>
<li>例子：定时器回调、ajax回调、Promise的成功或失败的回调。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"延时函数"</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"setTimeout之后"</span>);</span><br><span class="line"><span class="comment">//打印顺序：setTimeout之后，延时函数</span></span><br></pre></td></tr></table></figure>
<h4 id="Promise是什么"><a href="#Promise是什么" class="headerlink" title="Promise是什么"></a>Promise是什么</h4></li>
<li>抽象说法：<code>Promise</code>是JS中进行异步编程的新的解决方案。</li>
<li>从语法上来说，<code>Promise</code>是一个构造函数。</li>
<li>从功能上来说，<code>Promise</code>对象用来封装一个异步操作并可以获取其结果。<h4 id="Promise的状态改变"><a href="#Promise的状态改变" class="headerlink" title="Promise的状态改变"></a>Promise的状态改变</h4></li>
<li><code>pending</code>变为<code>resolved</code></li>
<li><code>pending</code>变为<code>rejected</code></li>
<li>只有这两种，并且<code>Promise</code>对象只能改变一次。</li>
<li>无论成功还是失败，都会有一个数据结果，成功的数据结果一般称为<code>value</code>，失败的数据结果一般称为<code>reason</code>。</li>
</ul>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建一个新的promise对象</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//2.执行异步操作</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="comment">//3.1.如果成功了，调用resolve(value)</span></span><br><span class="line">    <span class="keyword">if</span> (time % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      resolve(<span class="string">"成功的数据，time="</span> + time);</span><br><span class="line">  <span class="comment">//3.2.如果失败了，调用reject(reason)</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">"失败的数据，time="</span> + time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  p.then(</span><br><span class="line">    <span class="comment">//接受得到成功的value数据 OnResolved</span></span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"成功的回调"</span>, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//接受得到失败的reason数据  OnRejected</span></span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"失败的回调"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<h4 id="为什么要用Promise"><a href="#为什么要用Promise" class="headerlink" title="为什么要用Promise"></a>为什么要用Promise</h4><ul>
<li><p><strong>指定回调函数的方式更加灵活。</strong><br>旧的：必须在启动异步任务前指定回调函数；<br><code>Promise</code>：启动异步任务 =&gt; 返回<code>Promise</code>对象 =&gt; 给<code>Promise</code>对象绑定回调函数(甚至可以在异步任务结束后指定)。</p>
</li>
<li><p><strong>支持链式调用, 可以解决回调地狱问题。</strong><br>什么是回调地狱? 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调函数执行的条件。<br>回调地狱的缺点?  不便于阅读、不便于异常处理。</p>
</li>
</ul>
<h4 id="Promise的API"><a href="#Promise的API" class="headerlink" title="Promise的API"></a>Promise的API</h4><ol>
<li><p><strong><code>Promise</code>构造函数: <code>Promise (excutor) {}</code></strong><br><code>excutor</code>函数: 同步执行  <code>(resolve, reject) =&gt; {}</code>；<br><code>resolve</code>函数: 内部定义成功时我们调用的函数 <code>value =&gt; {}</code>；<br><code>reject</code>函数: 内部定义失败时我们调用的函数 <code>reason =&gt; {}</code>；<br>说明: <code>excutor</code>会在<code>Promise</code>内部立即同步回调,异步操作在执行器中执行。</p>
</li>
<li><p><strong><code>Promise.prototype.then</code>方法: <code>(onResolved, onRejected) =&gt; {}</code></strong><br><code>onResolved</code>函数: 成功的回调函数  <code>(value) =&gt; {}</code>；<br><code>onRejected</code>函数: 失败的回调函数 <code>(reason) =&gt; {}</code>；<br>说明: 指定用于得到成功<code>value</code>的成功回调和用于得到失败<code>reason</code>的失败回调，返回一个新的<code>Promise</code>对象。</p>
</li>
<li><p><strong><code>Promise.prototype.catch</code>方法: <code>(onRejected) =&gt; {}</code></strong><br><code>onRejected</code>函数: 失败的回调函数 <code>(reason) =&gt; {}</code>；<br>说明: <code>then()</code>的语法别名, 相当于: <code>then(undefined, onRejected)</code>。</p>
</li>
<li><p><strong><code>Promise.resolve</code>方法: <code>(value) =&gt; {}</code></strong><br><code>value</code>: 成功的数据或<code>Promise</code>对象，如果参数是 <code>Promise</code> 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。<br>说明: 返回一个成功/失败的<code>Promise</code>对象。</p>
</li>
<li><p><strong><code>Promise.reject</code>方法: <code>(reason) =&gt; {}</code></strong><br><code>reason</code>: 失败的原因；<br>说明: 返回一个失败的<code>Promise</code>对象。</p>
</li>
<li><p><strong><code>Promise.all</code>方法: <code>(promises) =&gt; {}</code></strong><br><code>promises</code>: 包含n个<code>promise</code>的数组；<br>说明: 返回一个新的<code>promise</code>, 只有所有的<code>promise</code>都成功才成功, 只要有一个失败了就直接失败。</p>
</li>
<li><p><strong><code>Promise.race</code>方法: <code>(promises) =&gt; {}</code></strong><br><code>promises</code>: 包含n个<code>promise</code>的数组；<br>说明: 返回一个新的<code>promise</code>, 第一个完成的<code>promise</code>的结果状态就是最终的结果状态。</p>
</li>
</ol>
<ul>
<li><code>then</code>和<code>catch</code>的示例。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"成功数据"</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"成功调用"</span>, value);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">reson</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"失败调用"</span>, reason);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//成功调用 成功数据</span></span><br></pre></td></tr></table></figure></li>
<li><code>Promise.resolve</code>和<code>Promise.reject</code>示例。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(value)&#125;);  <span class="comment">//1</span></span><br><span class="line">p2.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(value)&#125;);  <span class="comment">//2</span></span><br><span class="line">p3.catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(reason)&#125;);  <span class="comment">//3</span></span><br></pre></td></tr></table></figure></li>
<li><code>Promise.all</code>和<code>Promise.race</code>示例。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pAll = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br><span class="line">pAll.then(</span><br><span class="line">  values =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功"</span>, values);</span><br><span class="line">  &#125;,</span><br><span class="line">  reason =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败"</span>, reason);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//失败 3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pAll = <span class="built_in">Promise</span>.all([p1, p2]);</span><br><span class="line">pAll.then(</span><br><span class="line">  values =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功"</span>, values);</span><br><span class="line">  &#125;,</span><br><span class="line">  reason =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败"</span>, reason);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//成功 [1, 2]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pRace = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br><span class="line">pRace.then(</span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功"</span>, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  reason =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败"</span>, reason);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 成功 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pRace = <span class="built_in">Promise</span>.race([p3, p2, p1]);</span><br><span class="line">pRace.then(</span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功"</span>, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  reason =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败"</span>, reason);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 失败 3</span></span><br></pre></td></tr></table></figure></li>
<li>下面代码中，p1会<code>resolved</code>，p2首先会<code>rejected</code>，但是p2有自己的<code>catch</code>方法，该方法返回的是一个新的 <code>Promise</code> 实例，p2指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// ["hello", Error: 报错了]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Promise几个关键问题"><a href="#Promise几个关键问题" class="headerlink" title="Promise几个关键问题"></a>Promise几个关键问题</h4><h5 id="如何改变Promise的状态"><a href="#如何改变Promise的状态" class="headerlink" title="如何改变Promise的状态?"></a><strong>如何改变<code>Promise</code>的状态?</strong></h5><ul>
<li><code>resolve(value)</code>：如果当前是<code>pendding</code>就会变为<code>resolved</code>；</li>
<li><code>reject(reason)</code>：如果当前是<code>pendding</code>就会变为<code>rejected</code>；</li>
<li>抛出异常：如果当前是<code>pendding</code>就会变为<code>rejected</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"出错了"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">//Error: 出错了</span></span><br></pre></td></tr></table></figure>
<h5 id="一个Promise指定多个成功-失败回调函数-都会调用吗"><a href="#一个Promise指定多个成功-失败回调函数-都会调用吗" class="headerlink" title="一个Promise指定多个成功/失败回调函数, 都会调用吗?"></a>一个<code>Promise</code>指定多个成功/失败回调函数, 都会调用吗?</h5></li>
<li>当<code>Promise</code>改变为对应状态时都会调用。</li>
</ul>
<h5 id="改变Promise状态和指定回调函数谁先谁后"><a href="#改变Promise状态和指定回调函数谁先谁后" class="headerlink" title="改变Promise状态和指定回调函数谁先谁后?"></a>改变<code>Promise</code>状态和指定回调函数谁先谁后?</h5><ul>
<li>都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1</span>); <span class="comment">//后改变的状态（同时指定数据），异步执行回调函数</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(    <span class="comment">//先指定回调函数，保存当前指定的回调函数</span></span><br><span class="line">    value =&gt; &#123;<span class="built_in">console</span>.log(value)&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>如何先改状态再指定回调?</li>
</ul>
<p>（1）在执行器中直接调用<code>resolve()</code>或者<code>reject()</code>；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1</span>); <span class="comment">//先改变的状态（同时指定数据）</span></span><br><span class="line">&#125;).then(    <span class="comment">//后指定回调函数，异步执行回调函数</span></span><br><span class="line">    value =&gt; &#123;<span class="built_in">console</span>.log(value)&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>（2）延迟更长时间才调用<code>then()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p =<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1</span>); <span class="comment">//先改变的状态（同时指定数据）</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//后指定回调函数，异步执行回调函数</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(value)&#125;)</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>什么时候才能得到数据?<br>（1）如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据；<br>（2）如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据。</li>
</ul>
<h5 id="then-返回的新Promise的结果状态由什么决定"><a href="#then-返回的新Promise的结果状态由什么决定" class="headerlink" title="then()返回的新Promise的结果状态由什么决定?"></a>then()返回的新Promise的结果状态由什么决定?</h5><ul>
<li>简单表达: 由<code>then()</code>指定的回调函数执行的结果决定。</li>
<li>详细表达:<br>（1）如果抛出异常, 新<code>Promise</code>变为<code>rejected</code>, <code>reason</code>为抛出的异常；<br>（2）如果返回的是非<code>Promise</code>的任意值, 新<code>Promise</code>变为<code>resolved</code>, <code>value</code>为返回的值；<br>（3）如果返回的是另一个新<code>Promise</code>, 此<code>Promise</code>的结果就会成为新<code>Promise</code>的结果 。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"yes"</span>);</span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功1"</span>, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"失败1"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功2"</span>, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"失败2"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//成功1 yes</span></span><br><span class="line"><span class="comment">//成功2 undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">"no"</span>);</span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功1"</span>, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"失败1"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功2"</span>, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"失败2"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//失败1 no</span></span><br><span class="line"><span class="comment">//成功2 undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"yes"</span>);</span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功1"</span>, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"yes again"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"失败1"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功2"</span>, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"失败2"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//成功1 yes</span></span><br><span class="line"><span class="comment">//成功2 yes again</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"yes"</span>);</span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功1"</span>, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">"no"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"失败1"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功2"</span>, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"失败2"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//成功1 yes</span></span><br><span class="line"><span class="comment">//失败2 no</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="Promise如何串连多个操作任务"><a href="#Promise如何串连多个操作任务" class="headerlink" title="Promise如何串连多个操作任务?"></a>Promise如何串连多个操作任务?</h5><ul>
<li><code>Promise</code>的<code>then()</code>返回一个新的<code>Promise</code>, 可以写成<code>then()</code>的链式调用。</li>
<li>通过<code>then</code>的链式调用串连多个同步/异步任务。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"执行任务1（异步）"</span>);</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>  </span><br><span class="line">    )   </span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"任务1的结果是："</span>, value);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"执行任务2（同步）"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"任务2的结果是："</span>, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"执行任务3（异步）"</span>);</span><br><span class="line">                resolve(<span class="number">3</span>);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"任务3的结果是："</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行任务1（异步）</span></span><br><span class="line"><span class="comment">任务1的结果是： 1</span></span><br><span class="line"><span class="comment">执行任务2（同步）</span></span><br><span class="line"><span class="comment">任务2的结果是： 2</span></span><br><span class="line"><span class="comment">执行任务3（异步）</span></span><br><span class="line"><span class="comment">任务3的结果是： 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="Promise异常传透"><a href="#Promise异常传透" class="headerlink" title="Promise异常传透"></a>Promise异常传透</h5><ul>
<li>当使用<code>Promise</code>的<code>then</code>链式调用时, 可以在最后指定失败的回调，前面任何操作出了异常, 都会传到最后失败的回调中处理。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">1</span>);</span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功1"</span>, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功2"</span>, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">).catch(</span><br><span class="line">    reason =&gt; </span><br><span class="line">    &#123;<span class="built_in">console</span>.log(<span class="string">"失败"</span>, reason);&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//失败 1</span></span><br></pre></td></tr></table></figure></li>
<li><code>then</code>里没写<code>reason</code>时，会自动执行，并不是直接从最上面直接跳到最下面<code>catch</code>，而是一层一层传递的。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">reason =&gt; &#123;<span class="keyword">throw</span> reason&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="中断Promise链"><a href="#中断Promise链" class="headerlink" title="中断Promise链"></a>中断Promise链</h5><ul>
<li>当使用<code>Promise</code>的<code>then</code>链式调用时, 在中间中断, 不再调用后面的回调函数。</li>
<li>办法: 在回调函数中返回一个<code>pending</code>状态的<code>Promise</code>对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">1</span>);</span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功1"</span>, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功2"</span>, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">).catch(</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"失败"</span>, reason);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">).then(    <span class="comment">//下面不再执行</span></span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功3"</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//失败 1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Promise专辑</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义Promise-ES5匿名函数方法</title>
    <url>/2020/07/24/%E8%87%AA%E5%AE%9A%E4%B9%89Promise-ES5%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>代码如下：</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义Promise</span></span><br><span class="line"><span class="comment">// ES5匿名函数自调用实现模块化</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//excutor：执行器函数（同步执行）</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">excutor</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//将当前Promise对象保存起来</span></span><br><span class="line">        <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">        self.status = <span class="string">"pending"</span>;    <span class="comment">//给Promise对象指定status属性，初始状态为pending</span></span><br><span class="line">        self.data = <span class="literal">undefined</span>;  <span class="comment">//给Promise对象指定一个用于存储结果数据的属性</span></span><br><span class="line">        self.callbacks = [];    <span class="comment">//每个元素的结构&#123;onResolved() &#123;&#125;, onRejected() &#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//如果当前状态不是pending，直接结束，因为状态只能改一次</span></span><br><span class="line">            <span class="keyword">if</span> (self.status !== <span class="string">"pending"</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            self.status = <span class="string">"resolved"</span>; <span class="comment">//将状态改为resolved</span></span><br><span class="line">            self.data = value;  <span class="comment">//保存value数据</span></span><br><span class="line">            <span class="comment">//如果有待执行的callback函数，立即异步执行回调函数onResolved</span></span><br><span class="line">            <span class="keyword">if</span> (self.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                setTimeout(self.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span>   <span class="comment">//放入队列中执行所有成功的回调</span></span><br><span class="line">                    callbacksObj.onResolved(value)), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">             <span class="comment">//如果当前状态不是pending，直接结束，因为状态只能改一次</span></span><br><span class="line">             <span class="keyword">if</span> (self.status !== <span class="string">"pending"</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            self.status = <span class="string">"resjected"</span>; <span class="comment">//将状态改为rejected</span></span><br><span class="line">            self.data = reason;  <span class="comment">//保存reason数据</span></span><br><span class="line">            <span class="comment">//如果有待执行的callback函数，立即异步执行回调函数onRejected</span></span><br><span class="line">            <span class="keyword">if</span> (self.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                setTimeout(self.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span>   <span class="comment">//放入队列中执行所有失败的回调</span></span><br><span class="line">                    callbacksObj.onRejected(reason)), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//立即同步执行excutor</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            excutor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(error) &#123;    <span class="comment">//如果执行器抛出异常，Promise对象变成rejected状态</span></span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prmise原型对象的then方法</span></span><br><span class="line">    <span class="comment">//指定成功和失败的回调函数</span></span><br><span class="line">    <span class="comment">//返回一个新的Promise对象</span></span><br><span class="line">    <span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//向后传递成功的value</span></span><br><span class="line">        onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">"function"</span> ? onResolved : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        <span class="comment">//指定默认的失败的回调，实现异常穿透的关键</span></span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> self = <span class="keyword">this</span>;     </span><br><span class="line">        <span class="comment">//返回一个新的Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用成功的回调函数 onResolved</span></span><br><span class="line">            <span class="comment">//1.如果抛出异常，return的Promise对象就会失败，reason就是error</span></span><br><span class="line">            <span class="comment">//2.如果回调函数返回不是Promise对象, return的Promise对象就会成功，value就是返回的值</span></span><br><span class="line">            <span class="comment">//3.如果回调函数返回是Promise对象, return的Promise对象结果就是这个Promise对象的结果</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = callback(self.data);</span><br><span class="line">                    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">                        result.then(resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (self.status === <span class="string">"pending"</span>) &#123;</span><br><span class="line">                <span class="comment">//当前状态还是pending状态，将回调函数存起来</span></span><br><span class="line">                self.callbacks.push(&#123;</span><br><span class="line">                    onResolved(value) &#123;</span><br><span class="line">                        handle(onResolved);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    onRejected(reason) &#123;</span><br><span class="line">                        handle(onRejected);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.status === <span class="string">"resolved"</span>) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    handle(onResolved);</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    handle(onRejected);</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prmise原型对象的catch方法</span></span><br><span class="line">    <span class="comment">//指定失败的回调函数</span></span><br><span class="line">    <span class="comment">//返回一个新的Promise对象</span></span><br><span class="line">    <span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Promise函数对象的resolve方法</span></span><br><span class="line">    <span class="comment">//返回一个指定value的成功的Promise对象</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//返回一个成功或者失败的Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123; <span class="comment">//value是Promise对象</span></span><br><span class="line">                value.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//value不是Promise对象</span></span><br><span class="line">                resolve(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Promise函数对象的reject方法</span></span><br><span class="line">    <span class="comment">//返回一个指定reason的失败的Promise对象</span></span><br><span class="line">    <span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//返回一个失败的Promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Promise函数对象的all方法</span></span><br><span class="line">    <span class="comment">//返回一个Promise对象，只有promises全部成功才成功，否则失败</span></span><br><span class="line">    <span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//指定数组的长度</span></span><br><span class="line">        <span class="keyword">const</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(promises.length);</span><br><span class="line">        <span class="comment">//设置一个计数器</span></span><br><span class="line">        <span class="keyword">let</span> resolveCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promises.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">Promise</span>.resolve(p).then(    <span class="comment">//p有可能不是一个Promise对象</span></span><br><span class="line">                    value =&gt; &#123;</span><br><span class="line">                        resolveCount++;</span><br><span class="line">                        values[index] = value;</span><br><span class="line">                        <span class="keyword">if</span> (resolveCount === promises.length) &#123;</span><br><span class="line">                            resolve(values);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    reason =&gt; &#123;</span><br><span class="line">                        reject(reason);</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//Promise函数对象的race方法</span></span><br><span class="line">     <span class="comment">//返回一个Promise对象，成功失败由第一个完成的Promise对象决定</span></span><br><span class="line">     <span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promises.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">                    value =&gt; &#123;</span><br><span class="line">                        resolve(value);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    reason =&gt; &#123;</span><br><span class="line">                        reject(reason);</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个Promise对象，在指定的时间后确定结果</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolveDelay = <span class="function"><span class="keyword">function</span>(<span class="params">value, time</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//返回一个成功或者失败的Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123; <span class="comment">//value是Promise对象</span></span><br><span class="line">                    value.then(resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//value不是Promise对象</span></span><br><span class="line">                    resolve(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, time);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个Promise对象，在指定的时间后失败</span></span><br><span class="line">    <span class="built_in">Promise</span>.rejectDelay = <span class="function"><span class="keyword">function</span>(<span class="params">reason, time</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                reject(reason)</span><br><span class="line">            &#125;, time);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向外暴露Promise函数</span></span><br><span class="line">    <span class="built_in">window</span>.Promise = <span class="built_in">Promise</span>;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Promise专辑</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>async函数和await表达式</title>
    <url>/2020/07/24/async%E5%87%BD%E6%95%B0%E5%92%8Cawait%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h3><ol>
<li>函数返回值为<code>Promise</code>对象。<a id="more"></a>


</li>
</ol>
<ol start="2">
<li><code>Promise</code>对象的结果由<code>async</code>函数执行的返回值决定。</li>
</ol>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>返回一个成功的<code>Promise</code>对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = f();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br><span class="line"><span class="comment">// 一个resolved状态value为1的Promise对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = f();</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功"</span>, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"失败"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 成功 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回一个失败的<code>Promise</code>对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = f();</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功"</span>, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"失败"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 失败 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = f();</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功"</span>, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"失败"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 失败 1</span></span><br></pre></td></tr></table></figure>

<h3 id="await表达式"><a href="#await表达式" class="headerlink" title="await表达式"></a>await表达式</h3><ol>
<li><p><code>await</code>必须写在<code>async</code>函数中，但<code>async</code>函数中可以没有<code>await</code>。</p>
</li>
<li><p>如果<code>Promise</code>对象失败了，就会抛出异常，需要通过<code>try...catch</code>来捕获处理。</p>
</li>
</ol>
<h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li><code>await</code>表达式右侧是<code>Promise</code>对象，得到的结果就是<code>Promise</code>对象成功的<code>value</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">await</span> f1();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"value"</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2();</span><br><span class="line"><span class="comment">//value 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">await</span> f1();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"value"</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2();</span><br><span class="line"><span class="comment">//value 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>await</code>表达式右侧不是<code>Promise</code>对象，得到的结果就是表达式值本身。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">await</span> f1();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"value"</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2();</span><br><span class="line"><span class="comment">//value 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要得到失败的结果，用<code>try..catch</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="keyword">await</span> f1();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"value"</span>, value);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"得到失败的结果"</span>, error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2();</span><br><span class="line"><span class="comment">//得到失败的结果 1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Promise专辑</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/07/25/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（有些语言称为指针或者连接）组成。<a id="more"></a>


</li>
</ul>
<ul>
<li>相对于数组的优点：<ol>
<li>链表中的元素在内存中不必须是连续的空间，可以充分利用计算机的内存，实现灵活的内存动态管理；</li>
<li>链表不必在创建空间时就确定大小，并且大小可以无限的延伸下去；</li>
<li>链表在插入和删除数据时，时间复杂度可以达到<code>O(1)</code>，相对数组效率高很多。</li>
</ol>
</li>
</ul>
<ul>
<li>相对于数组的缺点：<ol>
<li>链表访问任何一个位置的元素时，都需要从头开始访问，无法跳过第一个元素访问任何一个元素；</li>
<li>无法通过下标直接访问元素，需要从头一个一个访问，直到找到对应的元素。</li>
</ol>
</li>
</ul>
<h4 id="常见操作及实现"><a href="#常见操作及实现" class="headerlink" title="常见操作及实现"></a>常见操作及实现</h4><p>用ES6封装实现，先列出<code>constructor</code>函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>append(element)</code>：向链表尾部添加一个新的项。<br>两种情况：（1）链表本身为空，新添加的项是唯一的节点；（2）链表不为空，需要向其它节点后面追加节点。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">append(element) &#123;</span><br><span class="line">        <span class="comment">//1.根据element创建node对象</span></span><br><span class="line">        <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(element);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.追加</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.head) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">while</span>(current.next) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>insert(position, element)</code>：向链表的特定位置插入一个新的项。<br>两种情况：（1）插入位置<code>position = 0</code>；（2）插入位置<code>position != 0</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">insert(position, element) &#123;</span><br><span class="line">        <span class="comment">//1.判断越界问题</span></span><br><span class="line">        <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建新节点</span></span><br><span class="line">        <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(element);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.插入元素</span></span><br><span class="line">        <span class="keyword">if</span>(position === <span class="number">0</span>) &#123;</span><br><span class="line">            newNode.next = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head = newNode;   </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">let</span> previous = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; position) &#123;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            newNode.next = current;</span><br><span class="line">            previous.next = newNode;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.length++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>get(position)</code>：获取对应位置的元素。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>(position) &#123;</span><br><span class="line">        <span class="comment">//1.判断越界问题</span></span><br><span class="line">        <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.查找元素的位置</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; position) &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>indexOf(element)</code>：返回元素在链表中的索引，如果链表中没有该元素则返回-1。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">indexOf(element) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            <span class="keyword">if</span>(current.element === element) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>removeAt(position)</code>：从链表的特定位置移除一项。<br>两种情况：（1）插入位置<code>position = 0</code>；（2）插入位置<code>position != 0</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">removeAt(position) &#123;</span><br><span class="line">        <span class="comment">//1.判断越界问题</span></span><br><span class="line">        <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">let</span> previous = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(position === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> index = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">while</span>(index &lt; position) &#123;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">                index ++;</span><br><span class="line">            &#125;</span><br><span class="line">            previous.next = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length--;</span><br><span class="line">        <span class="keyword">return</span> current.element; <span class="comment">//返回被移除的元素</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>update(position, element)</code>：修改某个位置的元素。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">update(position, element) &#123;</span><br><span class="line">        <span class="comment">//1.删除position位置的元素</span></span><br><span class="line">        <span class="keyword">const</span> replace =<span class="keyword">this</span>.removeAt(position);</span><br><span class="line">        <span class="comment">//2.在position位置插入新元素</span></span><br><span class="line">        <span class="keyword">this</span>.insert(position, element);</span><br><span class="line">        <span class="keyword">return</span> replace; <span class="comment">//返回被替换掉的元素</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>remove(element)</code>：从链表中移除一项。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">remove(element) &#123;</span><br><span class="line">        <span class="comment">//1.获取元素的位置</span></span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.删除这个位置的元素</span></span><br><span class="line">        <span class="keyword">this</span>.removeAt(index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>isEmpty()</code>：如果链表中不包含任何元素，返回<code>true</code>，如果链表长度大于0则返回<code>false</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size()</code>：返回链表包含的元素个数，与数组的<code>length</code>属性类似。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><ul>
<li>单向链表的明显缺点：<br>虽然可以轻松到达下一个节点，但是回到前一个节点是很难的，但是在实际开发中，经常遇到需要回到上一个节点的情况。</li>
</ul>
<ul>
<li>双向链表既可以从头遍历到尾，也可以从尾遍历到头，链表相连的过程是双向的，即一个节点既有向前连接的引用，也有一个向后连接的引用。</li>
</ul>
<ul>
<li>双向链表的缺点：<ol>
<li>每次插入或者删除某个节点时，需要处理4个引用，而不是2个，实现起来要困难一些；</li>
<li>占用内存空间更大；</li>
</ol>
</li>
</ul>
<ul>
<li>继承单向链表类实现双向链表</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">DoubleNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">super</span>(element);</span><br><span class="line">        <span class="keyword">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//append(element)：向链表尾部添加一个新的项</span></span><br><span class="line">    append(element) &#123;</span><br><span class="line">        <span class="comment">//1.创建节点</span></span><br><span class="line">        <span class="keyword">const</span> newNode = <span class="keyword">new</span> DoubleNode(element);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.追加元素</span></span><br><span class="line">        <span class="comment">//原来没有任何元素</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = newNode;</span><br><span class="line">            <span class="keyword">this</span>.tail = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//原来有其它元素了</span></span><br><span class="line">            newNode.prev = <span class="keyword">this</span>.tail;</span><br><span class="line">            <span class="keyword">this</span>.tail.next = newNode;</span><br><span class="line">            <span class="keyword">this</span>.tail = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert(position, element)：向链表的特定位置插入一个新的项</span></span><br><span class="line">    insert(position, element) &#123;</span><br><span class="line">        <span class="comment">//1.判断越界问题</span></span><br><span class="line">        <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建新节点</span></span><br><span class="line">        <span class="keyword">const</span> newNode = <span class="keyword">new</span> DoubleNode(element);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.插入元素，三种情况</span></span><br><span class="line">        <span class="keyword">if</span>(position === <span class="number">0</span>) &#123;    <span class="comment">//3.1头部插入</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;    <span class="comment">//原来没有元素</span></span><br><span class="line">                <span class="keyword">this</span>.head = newNode;</span><br><span class="line">                <span class="keyword">this</span>.tail = newNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//原来有元素</span></span><br><span class="line">                newNode.next = <span class="keyword">this</span>.head;</span><br><span class="line">                <span class="keyword">this</span>.head.prev = newNode;</span><br><span class="line">                <span class="keyword">this</span>.head = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(position === <span class="keyword">this</span>.length) &#123;   <span class="comment">//3.2尾部插入</span></span><br><span class="line">            newNode.prev = <span class="keyword">this</span>.tail;</span><br><span class="line">            <span class="keyword">this</span>.tail.next = newNode; </span><br><span class="line">            <span class="keyword">this</span>.tail = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//3.3中间插入</span></span><br><span class="line">            <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">let</span> previous = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; position) &#123;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            previous.next = newNode;</span><br><span class="line">            newNode.prev = previous;</span><br><span class="line">            current.prev = newNode;</span><br><span class="line">            newNode.next = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//get(position)：获取对应位置的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//indexOf(element)：返回元素在链表中的索引，如果链表中没有该元素则返回-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//removeAt(position)：从链表的特定位置移除一项</span></span><br><span class="line">    removeAt(position) &#123;</span><br><span class="line">        <span class="comment">//1.判断越界问题</span></span><br><span class="line">        <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.删除元素，分3种情况考虑</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">let</span> previous = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(position === <span class="number">0</span>) &#123;    <span class="comment">//2.1删除第一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.length === <span class="number">1</span>) &#123; <span class="comment">//只有一个元素</span></span><br><span class="line">                <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//并非只有一个元素</span></span><br><span class="line">                <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">                <span class="keyword">this</span>.head.prev = <span class="literal">null</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(position === <span class="keyword">this</span>.length <span class="number">-1</span> ) &#123;   <span class="comment">//2.2删除最后一个元素，此时不用再考虑只有一个元素的情况，因为如果只有一个元素，上面的情况已经确保了position = 0</span></span><br><span class="line">            current = <span class="keyword">this</span>.tail;</span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="keyword">this</span>.tail.prev;</span><br><span class="line">            <span class="keyword">this</span>.tail.next = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; position) &#123;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            previous.next = current.next;</span><br><span class="line">            current.next.prev = previous;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.length--;</span><br><span class="line">        <span class="keyword">return</span> current.element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//update(position, element)：修改某个位置的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//remove(element)：从链表中移除一项</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//size()：返回链表包含的元素个数，与数组的length属性类似</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法的JS实现</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数组、栈、队列</title>
    <url>/2020/07/25/%E6%95%B0%E7%BB%84%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="数组-array"><a href="#数组-array" class="headerlink" title="数组(array)"></a>数组(array)</h3><ul>
<li><strong>大O表示法</strong><ul>
<li>O(1) 常数的</li>
<li>O(log(n)) 对数的</li>
<li>O(n) 线性的</li>
<li>O(nlog(n)) 线性和对数的乘积</li>
<li>O(n&lt;sup&gt;2&lt;/sup&gt;) 平方</li>
<li>O(2&lt;sup&gt;n&lt;/sup&gt;) 指数</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li>c语言中的数组：<ol>
<li>数组必须存放相同的类型；</li>
<li>申请数组的内存空间时，必须指定数组的大小。</li>
</ol>
</li>
</ul>
<ul>
<li><strong>数组影响性能的两点因素</strong><ol>
<li>数组的创建通常需要申请一段连续的内存空间（一整块的内存），并且大小是固定的（大多数编程语言数组都是固定的），所以当目前的数组不能满足容量需求时，需要扩容（一般情况下是申请一个更大的数组，比如2倍，然后将原数组的元素复制过去）；</li>
<li>在数组中间或者前面插入或者删除元素的性能非常低，在数组中间或者前面插入元素，需要将元素依次往后移动，删除素也是同理，需要将删除元素后面的元素依次前移。</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>数组性能的优势</strong><br>数据放到数组之中，数组查找效率非常高，只要找到元素下标值，查找效率为O(1)，一次性找到。</p>
</li>
<li><p><strong>JS语言中的数组底层实现，是通过哈希表或者字典实现的，目前正在慢慢的靠向c语言的实现方式，因为这样效率更高。</strong></p>
</li>
</ul>
<h3 id="栈结构-Stack"><a href="#栈结构-Stack" class="headerlink" title="栈结构(Stack)"></a>栈结构(Stack)</h3><ul>
<li><strong>实现栈结构两种比较常见的方式</strong><ol>
<li>基于数组实现；</li>
<li>基于链表实现。</li>
</ol>
</li>
</ul>
<ul>
<li>利用ES6实现Stack结构</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//push(element)：添加一个元素到栈顶位置</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pop()：移除栈顶的元素，同时返回被移除的元素</span></span><br><span class="line">    pop() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//peek()：返回栈顶的元素，但是不将其移除</span></span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//isEmpty()：如果栈为空，返回true，不为空则返回false</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//size()：返回栈里元素的个数</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用栈结构实现十进制转二进制</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec2bin</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">//循坏取余数，压入栈</span></span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> mod = num % <span class="number">2</span>;</span><br><span class="line">        stack.push(mod);</span><br><span class="line">        num = <span class="built_in">Math</span>.floor(num / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拼接字符串</span></span><br><span class="line">    <span class="keyword">let</span> binString= <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        binString += stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h3><ul>
<li><strong>实现队列结构两种比较常见的方式</strong><ol>
<li>基于数组实现；</li>
<li>基于链表实现。</li>
</ol>
</li>
</ul>
<ul>
<li>利用ES6实现Queue结构</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//enqueue(element)：向队尾添加一个（或者多个）新的元素</span></span><br><span class="line">    enqueue(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//dequeue()：移除队列第一的元素，即排在最前面的元素，同时返回被移除的元素</span></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.shift();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//front()：查看第一个元素，但是并不移除</span></span><br><span class="line">    front() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.items.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.items[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//isEmpty()：如果队列中不包含任何项，返回true，否则返回false</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//size()：返回队列中元素的个数</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用Queue实现击鼓传花游戏</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passGame</span>(<span class="params">namaList, num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建队列</span></span><br><span class="line">    <span class="keyword">const</span> queue  = <span class="keyword">new</span> Queue();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; namaList.length; i++) &#123;</span><br><span class="line">        queue.enqueue(namaList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.让这些人在队列中数数循环，人是从1开始数，数到num的人淘汰，直到只剩一个人胜利</span></span><br><span class="line">    <span class="keyword">while</span>(queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            queue.enqueue(queue.dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">        queue.dequeue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优先级队列<br>优先级队列在插入一个元素时会考虑数据的优先级，和其它元素进行比较，比较完成后，可以得出这个元素的正确位置。其它处理方式和基本队列的处理方式一致。<br>需要考虑的问题：</li>
</ul>
<ol>
<li>每个元素不再只是一个数据，而是包含数据的优先级；</li>
<li>在添加方式中，根据优先级放入正确的位置。</li>
</ol>
<ul>
<li>实现优先级队列</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装优先级队列的元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element, priority) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级队列，继承普通队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span> <span class="keyword">extends</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    enqueue(element, priority) &#123;</span><br><span class="line">        <span class="keyword">let</span> queueElement = <span class="keyword">new</span> QueueElement(element, priority);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.items.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.items.push(queueElement);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> added = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.items.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.items[i].priority &gt; queueElement.priority) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.items.splice(i, <span class="number">0</span>, queueElement);</span><br><span class="line">                    added = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!added) &#123;</span><br><span class="line">                <span class="keyword">this</span>.items.push(queueElement);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法的JS实现</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2020/07/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>首先封装一个ArrayList类，做一些准备工作。</p>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入数据的方法</span></span><br><span class="line">    insert(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array.push(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//转化成字符串方法</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.join(<span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个位置的数据</span></span><br><span class="line">    swap(m, n) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = <span class="keyword">this</span>.array[m];</span><br><span class="line">        <span class="keyword">this</span>.array[m] = <span class="keyword">this</span>.array[n];</span><br><span class="line">        <span class="keyword">this</span>.array[n] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul>
<li><strong>冒泡排序的思路：</strong></li>
</ul>
<ol>
<li><p>对未排序的各元素从头到尾依次比较相邻的两个元素大小关系；</p>
</li>
<li><p>如果左边的元素大， 则两元素交换位置；</p>
</li>
<li><p>向右移动一个位置, 比较下面两个元素；</p>
</li>
<li><p>当走到最右端时, 最大的元素一定被放在了最右边；</p>
</li>
<li><p>按照这个思路, 从最左端重新开始, 这次走到倒数第二个位置元素即可；</p>
</li>
<li><p>依次类推, 就可以将数据排序完成。</p>
</li>
</ol>
<ul>
<li>ES6代码实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line">bubbleSort() &#123;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="keyword">this</span>.array.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.array[j] &gt; <span class="keyword">this</span>.array[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">this</span>.swap(j, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>冒泡排序的复杂度<ul>
<li>冒泡排序的比较次数，对于n个数据来说，为(n - 1) + (n - 2) + (n - 3) + … + 1 = n * (n - 1) / 2，所以冒泡排序的大O表示法为<code>O(n²)</code>。</li>
<li>冒泡排序的交换次数，如果有两次比较才需要交换一次(不可能每次比较都交换一次.), 那么交换次数为n² / 4，交换次数的大O表示也是<code>O(n²)</code>。</li>
</ul>
</li>
</ul>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul>
<li><strong>选择排序的思路：</strong></li>
</ul>
<ol>
<li>选定第一个索引位置，然后和后面元素依次比较；</li>
<li>如果后面的元素, 小于索引位置的元素, 则将该元素的位置赋给索引元素；</li>
<li>经过一轮的比较后, 可以确定第一个位置是最小的；</li>
<li>然后使用同样的方法把剩下的元素逐个比较即可；</li>
<li>可以看出选择排序，第一轮会选出最小值，第二轮会选出第二小的值，直到最后。</li>
</ol>
<ul>
<li>ES6代码实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line">selectSort() &#123;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="keyword">this</span>.array.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.array[j] &lt; <span class="keyword">this</span>.array[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.swap(i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>选择排序的复杂度<ul>
<li>选择排序的比较次数是n*(n - 1)/2, 也就是<code>O(n²)</code>。</li>
<li>选择排序的交换次数只有n - 1次, 用大O表示法就是<code>O(n)</code>。</li>
</ul>
</li>
</ul>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul>
<li>局部有序:<ol>
<li>插入排序思想的核心是局部有序；</li>
<li>比如在一个数组中的元素, 我们选择其中一个作为标记的元素， 这个被标记的元素左边的所有元素已经是局部有序的.</li>
<li>这意味着, 有一部分元素是按顺序排列好的. 有一部分还没有顺序。</li>
</ol>
</li>
</ul>
<ul>
<li>插入排序的思路:<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前比较；</li>
<li>如果该元素（已排序的那个元素）大于新元素，将该元素移到下一位置；</li>
<li>重复上一个步骤，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后, 重复上面的步骤。</li>
</ol>
</li>
</ul>
<ul>
<li>ES6代码实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line">insertSort() &#123;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="keyword">this</span>.array.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> temp = <span class="keyword">this</span>.array[i];</span><br><span class="line">        <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.array[j] &gt; temp) &#123;</span><br><span class="line">            <span class="keyword">this</span>.array[j+<span class="number">1</span>] = <span class="keyword">this</span>.array[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.array[j+<span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>插入排序的比较次数:<br>第一趟时, 需要的<strong>最多</strong>次数是1, 第二趟最多次数是2, 依次类推, 最后一趟是n-1次；<br>因此是1 + 2 + 3 + … + n - 1 = n * (n - 1) / 2；<br>然而每趟发现插入点之前, 平均只有全体数据项的一半需要进行比较；<br>我们可以除以2得到 n * (n - 1) / 4，虽热也是是<code>O(n²)</code>，但是相对于选择排序， 其他比较次数是少了一半的。</p>
</li>
<li><p>插入排序的复制次数:<br>第一趟时,，需要的<strong>最多</strong>复制次数是1,，第二趟最多次数是2， 依次类推, 最后一趟是n-1次，因此是1 + 2 + 3 + … + n - 1 = n * (n - 1) / 2，也就是<code>O(n²)</code>。</p>
</li>
</ul>
<h3 id="高级排序"><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h3><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul>
<li><p>选择合适的增量:<br>在希尔排序的原稿中，建议的初始间距是n/ 2，简单的把每趟排序分成两半，也就是说，对于n = 100的数组，增量间隔序列为：50, 25, 12, 6, 3, 1。<br>这个方法的好处是不需要在开始排序前为找合适的增量而进行任何的计算，暂时按照这个增量来实现代码。</p>
</li>
<li><p>ES6代码实现</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line">shellSort() &#123;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="keyword">this</span>.array.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(length/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = <span class="keyword">this</span>.array[i];</span><br><span class="line">            <span class="keyword">let</span> j = i - gap;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.array[j] &gt; temp) &#123;</span><br><span class="line">                <span class="keyword">this</span>.array[j+gap] = <span class="keyword">this</span>.array[j];</span><br><span class="line">                j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.array[j+gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap = <span class="built_in">Math</span>.floor(gap/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>希尔排序的效率<br>希尔排序的效率很增量是有关系的，但是，它的效率证明非常困难，甚至某些增量的效率到目前依然没有被证明出来。<br>但是经过统计, 希尔排序使用原始增量, <strong>最坏的情况下时间复杂度为<code>O(n²)</code>，通常情况下都要好于<code>O(n²)</code></strong>。</li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul>
<li><p>快速排序的效率<br>一般情况下，快递排序的效率是最高的，最坏情况为<code>O(n²)</code>，平均效率为<code>O(nlog(n))</code>。</p>
</li>
<li><p>ES6代码实现</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">quickSort() &#123;</span><br><span class="line">    <span class="keyword">this</span>.quickSortHelp(<span class="number">0</span>, <span class="keyword">this</span>.array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">quickSortHelp(left, right) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.这一部分主要用于选择基准数据，三分取中</span></span><br><span class="line">    <span class="keyword">let</span> center = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保了center位置的元素一定比left位置的大</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.array[left] &gt; <span class="keyword">this</span>.array[center]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.swap(left, center);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保了right位置的元素一定是最大的</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.array[center] &gt; <span class="keyword">this</span>.array[right]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.swap(center, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果上一步中，center位置和right位置元素互换了，那么其实现在left位置的元素还没有和现在center位置的元素比较</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.array[left] &gt; <span class="keyword">this</span>.array[center]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.swap(left, center);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将center位置的元素和left位置的元素互换，所以基准到了left位置</span></span><br><span class="line">    <span class="comment">//其实可以和上面的一步合并成一步，但是为了方便理解，这里我写成了两步</span></span><br><span class="line">    <span class="keyword">this</span>.swap(left, center);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.记录一些值</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="keyword">this</span>.array[left];</span><br><span class="line">    <span class="comment">//i,j用于记录本次调整的范围，便于递归，因为后续left和right是变化的</span></span><br><span class="line">    <span class="keyword">let</span> i = left;</span><br><span class="line">    <span class="keyword">let</span> j = right;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.前后同时遍历</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="keyword">this</span>.array[right] &gt;= temp) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.array[left] = <span class="keyword">this</span>.array[right]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="keyword">this</span>.array[left] &lt;= temp) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.array[right] = <span class="keyword">this</span>.array[left];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//left位置左侧全部小于temp，left右侧全部大于temp</span></span><br><span class="line">    <span class="keyword">this</span>.array[left] = temp;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//4.递归</span></span><br><span class="line">    <span class="keyword">this</span>.quickSortHelp(i, left - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>.quickSortHelp(left + <span class="number">1</span>, j)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ul>
<li>归并排序的思路<br>归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。<br>1.分解（Divide）：将n个元素分成个含n/2个元素的子序列。<br>2.解决（Conquer）：用归并排序法对两个子序列递归的排序。<br>3.合并（Combine）：合并两个已排序的子序列已得到排序结果。<br><img src="https://pic4.zhimg.com/v2-a29c0dd0186d1f8cef3c5ebdedf3e5a3_b.webp" alt=""></li>
</ul>
<ul>
<li><p>复杂度分析<br>不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：O( nlogn )。<br>归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n + logn；所以空间复杂度为: O(n)。<br>归并排序算法中，归并最后到底都是相邻元素之间的比较交换，并不会发生相同元素的相对位置发生变化，故是稳定性算法。</p>
</li>
<li><p>ES6代码实现</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line">mergeSort() &#123;</span><br><span class="line">    <span class="keyword">let</span> sortArray = <span class="keyword">this</span>.mergeSortSplit(<span class="keyword">this</span>.array);</span><br><span class="line">    <span class="keyword">this</span>.array = [...sortArray];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拆分</span></span><br><span class="line">mergeSortSplit(array) &#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">    <span class="comment">//array一分为二</span></span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> left = array.slice(<span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">let</span> right = array.slice(middle, array.length);</span><br><span class="line">    <span class="comment">//递归拆分</span></span><br><span class="line">    <span class="keyword">let</span> leftSplit = <span class="keyword">this</span>.mergeSortSplit(left);</span><br><span class="line">    <span class="keyword">let</span> rightSplit = <span class="keyword">this</span>.mergeSortSplit(right);</span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mergeSortMerge(leftSplit, rightSplit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line">mergeSortMerge(left, right) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">while</span>(left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            res.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接剩下的那个</span></span><br><span class="line">    <span class="keyword">if</span>(left.length) &#123;</span><br><span class="line">        res = res.concat(left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = res.concat(right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="排序方法总结"><a href="#排序方法总结" class="headerlink" title="排序方法总结"></a>排序方法总结</h4><p><img src="https://upload-images.jianshu.io/upload_images/23609865-34cc5b46e6551a6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="JS里sort-的引擎实现"><a href="#JS里sort-的引擎实现" class="headerlink" title="JS里sort()的引擎实现"></a>JS里sort()的引擎实现</h3><ul>
<li><p>根据v8引擎的源码，<code>sort()</code>是基于插入排序和快速排序实现的。</p>
</li>
<li><p>对于数组长度小于等于10的，采用插入排序的方法。</p>
</li>
<li><p>对于数组长度大于10的，采用快速排序的方法。<br>1.数组长度大于1000的，基准的选择采用的三分中点法；<br>2.小于1000的，基准位置选择的是<code>from + ((to - from) &gt;&gt; 1)</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法的JS实现</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2020/07/25/%E6%A0%91/</url>
    <content><![CDATA[<h4 id="树的术语"><a href="#树的术语" class="headerlink" title="树的术语"></a>树的术语</h4><ul>
<li><p>树（<code>Tree</code>）：n个节点构成的有限集合。当n = 0时，称为空树。</p>
<a id="more"></a>
</li>
<li><p>树中有一个称为根的特殊节点“根（<code>Root</code>）”，用<code>r</code>表示。其余节点可以分为m个互不相交的有限集，其中每个集合本身又是一棵树，称为原来树的“子树（<code>SubTree</code>）”。</p>
</li>
<li><p>节点的度（<code>Degree</code>）：节点的子树个数。</p>
</li>
<li><p>树的度：树的所有节点中最大的度数。</p>
</li>
<li><p><strong>叶节点</strong>（<code>Leaf</code>）：度为0的节点。</p>
</li>
<li><p><strong>父节点</strong>（<code>Parent</code>）：有子树的节点是其子树的根节点的父节点。</p>
</li>
<li><p><strong>子节点</strong>（<code>Child</code>）：若A节点是B节点的父节点，则B节点是A节点的子节点。</p>
</li>
<li><p>兄弟节点（<code>Silbing</code>）：具有一个父节点的节点。</p>
</li>
<li><p>路径和路径长度：从节点n1到节点nk的路径为一个节点序列，路径所包含节点的个数为路径的长度。</p>
</li>
<li><p>节点的层次（<code>Level</code>）：规定根节点在1层，其它任一节点的层数是其父节点的层数加1。</p>
</li>
<li><p>树的深度（<code>Depth</code>）：树中所有节点中的最大层次是这棵树的深度。</p>
</li>
</ul>
<h4 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h4><ul>
<li>二叉树：如果树中每个节点最多只能有两个子节点，这样的树称为“二叉树”。</li>
</ul>
<ul>
<li><strong>二叉树的一些公式</strong>：<ol>
<li>一个二叉树第n层的最大节点数为：<code>2^(n-1)，n &gt;= 1</code>；</li>
<li>深度为k的二叉树最大节点总数为：<code>2^k - 1，k &gt;= 1</code>；</li>
<li>对任何非空二叉树T，若n0表示叶节点的个数，n2是度为2的非叶节点个数，那么两者满足<code>n0 = n2 + 1</code>。</li>
</ol>
</li>
</ul>
<ul>
<li><p>完美二叉树（满二叉树）：在二叉树中，除了最下一层的叶节点外，每个节点都有两个子节点。</p>
</li>
<li><p>完全二叉树：除了二叉树最后一层外，其它各层的节点都达到最大，并且最后一层从左到右的叶节点连续存在，只缺右侧若干节点。</p>
</li>
<li><p>平衡树(<code>Balance Tree，BT</code>) ：任意节点的子树的高度差都小于等于1。</p>
</li>
<li><p>二叉树最常见的方式是使用链表存储，每个节点封装成一个<code>Node</code>，<code>Node</code>中包含存储的数据，左节点的引用，右节点的引用。</p>
</li>
</ul>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ul>
<li><p>二叉搜索树（<code>BST</code>），也称为二叉排序树或者二叉查找树。</p>
</li>
<li><p>二叉搜索树是一棵二叉树，可以为空。</p>
</li>
</ul>
<ul>
<li>如果不为空，满足以下性质：<ol>
<li>非空左子树的所有键值小于其根节点的键值；</li>
<li>非空右子树的所有键值大于其根节点的键值；</li>
<li>左、右子树本身也都是二叉搜索树。</li>
</ol>
</li>
</ul>
<ul>
<li>二叉搜索树的特点就是相对较小的值总是存放在左节点，相对较大的值总是存放在右节点。所以二叉搜索树的查找效率非常高。</li>
</ul>
<ul>
<li>先序遍历<ol>
<li>访问根节点；</li>
<li>先序遍历其左子树；</li>
<li>先序遍历其右子树。</li>
</ol>
</li>
</ul>
<ul>
<li><strong>中序遍历：访问得到的键是从小到大排列的。</strong><ol>
<li>中序遍历其左子树；</li>
<li>访问根节点；</li>
<li>中序遍历其右子树。</li>
</ol>
</li>
</ul>
<ul>
<li>后序遍历<ol>
<li>后序遍历其左子树；</li>
<li>后序遍历其右子树；</li>
<li>访问根节点。</li>
</ol>
</li>
</ul>
<h4 id="常见操作及ES6实现"><a href="#常见操作及ES6实现" class="headerlink" title="常见操作及ES6实现"></a>常见操作及ES6实现</h4><ul>
<li><p><code>insert(key)</code>：向树中插入一个新的键</p>
</li>
<li><p><code>preOrderTraverse()</code>：通过先序遍历方式遍历所有节点</p>
</li>
<li><p><code>inOrderTraverse()</code>：通过中序遍历方式遍历所有节点</p>
</li>
<li><p><code>postOrderTraverse()</code>：通过后序遍历方式遍历所有节点</p>
</li>
<li><p><code>pathTraverse()</code>：遍历根节点到叶节点的所有路径</p>
</li>
<li><p><code>min()</code>：返回树中最小的键</p>
</li>
<li><p><code>max()</code>：返回树中最大的键</p>
</li>
<li><p><code>search(key)</code>：在树中查找一个键，如果存在返回<code>true</code>，否则返回<code>false</code></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert(key)：向树中插入一个新的键</span></span><br><span class="line">    insert(key) &#123;</span><br><span class="line">        <span class="comment">//1.根据key创建Node节点</span></span><br><span class="line">        <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.1如果是一课空树</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.root === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//2.2不是空树</span></span><br><span class="line">            <span class="keyword">this</span>.insertNode(<span class="keyword">this</span>.root, newNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向node节点后面插入newNode</span></span><br><span class="line">    insertNode(node, newNode) &#123;</span><br><span class="line">        <span class="keyword">if</span>(newNode.key === node.key) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (newNode.key &gt; node.key) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">                node.right = newNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.insertNode(node.right, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">                node.left = newNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.insertNode(node.left, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//preOrderTraverse()：通过先序遍历方式遍历所有节点</span></span><br><span class="line">    preOrderTraverse() &#123;</span><br><span class="line">        <span class="keyword">this</span>.preOrderTraverseNode(<span class="keyword">this</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preOrderTraverseNode(node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(node.key);  <span class="comment">//直接访问</span></span><br><span class="line">        <span class="keyword">this</span>.preOrderTraverseNode(node.left);</span><br><span class="line">        <span class="keyword">this</span>.preOrderTraverseNode(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//inOrderTraverse()：通过中序遍历方式遍历所有节点</span></span><br><span class="line">    inOrderTraverse() &#123;</span><br><span class="line">        <span class="keyword">this</span>.inOrderTraverseNode(<span class="keyword">this</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inOrderTraverseNode(node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.inOrderTraverseNode(node.left);</span><br><span class="line">        <span class="built_in">console</span>.log((node.key));</span><br><span class="line">        <span class="keyword">this</span>.inOrderTraverseNode(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//postOrderTraverse()：通过后序遍历方式遍历所有节点</span></span><br><span class="line">    postOrderTraverse() &#123;</span><br><span class="line">        <span class="keyword">this</span>.postOrderTraverseNode(<span class="keyword">this</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postOrderTraverseNode(node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.postOrderTraverseNode(node.left);</span><br><span class="line">        <span class="keyword">this</span>.postOrderTraverseNode(node.right);</span><br><span class="line">        <span class="built_in">console</span>.log((node.key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pathTraverse()遍历从根节点到叶节点的所有路径</span></span><br><span class="line">    pathTraverse() &#123;</span><br><span class="line">        <span class="keyword">let</span> path = <span class="keyword">this</span>.pathTraverseNode(<span class="keyword">this</span>.root);</span><br><span class="line">        <span class="built_in">console</span>.log(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pathTraverseNode(node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node === <span class="literal">null</span>) <span class="keyword">return</span> [];  <span class="comment">// 注意点，必须写[]，不能是别的！！！</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>) <span class="keyword">return</span> [[node.key]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> left = <span class="keyword">this</span>.pathTraverseNode(node.left);</span><br><span class="line">        <span class="keyword">let</span> right = <span class="keyword">this</span>.pathTraverseNode(node.right);</span><br><span class="line">        <span class="keyword">return</span> left.concat(right).map(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">            x.unshift(node.key);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//min()：返回树中最小的键</span></span><br><span class="line">    min() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">while</span>(node.left) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//max()：返回树中最大的键</span></span><br><span class="line">    max() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">while</span>(node.right) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//search(key)：在树中查找一个键，如果存在返回true，否则返回false</span></span><br><span class="line">    search(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(<span class="keyword">this</span>.root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    searchNode(node, key) &#123;</span><br><span class="line">        <span class="comment">//1.判断node有没有值</span></span><br><span class="line">        <span class="keyword">if</span>(node === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.判断搜索的key和节点值的关系</span></span><br><span class="line">        <span class="keyword">if</span>(key &lt; node.key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(node.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(node.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归的查找方法</span></span><br><span class="line">    search2(key) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(key &lt; node.key) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树的删除操作remove-key"><a href="#二叉搜索树的删除操作remove-key" class="headerlink" title="二叉搜索树的删除操作remove(key)"></a>二叉搜索树的删除操作<code>remove(key)</code></h4><p>二叉搜索树的删除操作非常复杂，先找到要删除的节点，找到后，需要考虑3种情况。</p>
<ul>
<li><p>该节点是叶节点</p>
</li>
<li><p>该节点有一个子节点</p>
</li>
<li><p>该节点有两个子节点</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">remove(key) &#123;</span><br><span class="line">        <span class="comment">//1.定义记录状态的变量</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">let</span> parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> isLeftChild = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.查找变量</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(current.key !== key) &#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            <span class="keyword">if</span>(key &lt; current.key) &#123;</span><br><span class="line">                isLeftChild = <span class="literal">true</span>;</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isLeftChild = <span class="literal">false</span>;</span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(current === <span class="literal">null</span>) &#123;  <span class="comment">//找到最后也没找到</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.找到节点</span></span><br><span class="line">        <span class="comment">//3.1删除的节点是叶节点</span></span><br><span class="line">        <span class="keyword">if</span>(current.left === <span class="literal">null</span> &amp;&amp; current.right === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(current === <span class="keyword">this</span>.root) &#123;</span><br><span class="line">                <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.2删除的节点有一个子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current.right === <span class="literal">null</span>) &#123;  <span class="comment">//只有左子节点</span></span><br><span class="line">            <span class="keyword">if</span>(current === <span class="keyword">this</span>.root) &#123;</span><br><span class="line">                <span class="keyword">this</span>.root = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current.left === <span class="literal">null</span>) &#123;    <span class="comment">//只有左子节点</span></span><br><span class="line">            <span class="keyword">if</span>(current === <span class="keyword">this</span>.root) &#123;</span><br><span class="line">                <span class="keyword">this</span>.root = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = current.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.3删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取后继节点</span></span><br><span class="line">            <span class="keyword">let</span> successor =  <span class="keyword">this</span>.getSuccessor(current);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否为根节点</span></span><br><span class="line">            <span class="keyword">if</span>(current === <span class="keyword">this</span>.root) &#123;</span><br><span class="line">                <span class="keyword">this</span>.root = successor;       </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = successor;</span><br><span class="line">            &#125;</span><br><span class="line">            successor.left = current.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找删除节点的后继节点</span></span><br><span class="line">    getSuccessor(delNode) &#123; </span><br><span class="line">        <span class="comment">//1.定义变量，储存临时节点</span></span><br><span class="line">        <span class="keyword">let</span> successorParent = delNode;</span><br><span class="line">        <span class="keyword">let</span> successor = delNode.right;</span><br><span class="line">        <span class="comment">//let current = delNode.right;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.寻找节点</span></span><br><span class="line">        <span class="keyword">while</span>(successor.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = successor.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(successor !== delNode.right) &#123;</span><br><span class="line">            successorParent.left = successor.right;</span><br><span class="line">            successor.right = delNode.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树的缺陷"><a href="#二叉搜索树的缺陷" class="headerlink" title="二叉搜索树的缺陷"></a>二叉搜索树的缺陷</h4><ul>
<li><p>二叉搜索树有一个很麻烦的问题，如果初始化一棵树9、8、12，然后插入数据7、6、5、4、3、2、1，在插入连续数据后，树的分布会不均匀，会形成一棵非平衡树。</p>
</li>
<li><p>对于一棵平衡二叉树来说，插入、查找等操作的效率是<code>O(log(n))</code>。</p>
</li>
<li><p>对于一棵非平衡二叉树，相当于一个链表，查找效率是<code>O(n)</code>。</p>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul>
<li>红黑树的特性<ol>
<li>节点是红色或黑色；</li>
<li>根节点是黑色；</li>
<li>每个叶节点都是黑色的空节点；</li>
<li>每个红色节点的两个子节点都是黑色（从每个叶节点到根节点的所有路径上不会出现两个连续的红色节点）；</li>
<li>从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点。</li>
</ol>
</li>
</ul>
<ul>
<li>前面的约束，保证了红黑树的关键特性-从根节点到叶节点的最长可能路径，不会超过最短可能路径的两倍。</li>
</ul>
<ul>
<li>为什么确保了最长路径不超过最短路径的两倍？<ul>
<li>性质4决定了路径不能有两个相连的红色节点，最短的可能路径都是黑色节点，最长的可能路径是红色和黑色交替，性质5规定所有路径都有相同数目的黑色节点，这就表明了没有路径能超过其它路径的两倍长。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法的JS实现</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2020/07/25/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>基于数组实现。</p>
</li>
<li><p>相对于数组的优点：<br>1.可以提供非常快速的插入、删除、查找操作；<br>2.无论多少数据，插入和删除值需要接近常量的时间：即<code>O(1)</code>的时间级；</p>
<a id="more"></a>
<p>3.哈希表的速度比树还要快，基本可以瞬间查找到想要的元素；<br>4.哈希表相对树来说编码更容易。</p>
</li>
<li><p>相对于数组的不足：<br>1.哈希表中的数据没有顺序，所以不能以一种固定的方式来遍历其中的元素；<br>2.通常情况下，哈希表中的<code>key</code>是不允许重复的，不能放置相同的<code>key</code>用于保存不同的元素；<br>3.空间利用率不高，底层使用的是数组，并且某些单元没有被利用；<br>4.不能快速的找到哈希表中的最大值或者最小值这些特殊的值。</p>
</li>
<li><p>哈希表的结构就是数组，但是它神奇的地方在于对下标值的一种变换，这种变换称为哈希函数，通过哈希函数可以获取<code>HashCode</code>（下标值）。</p>
</li>
<li><p>哈希化：将大数字转化成数组范围内下标的过程，称之为哈希化。</p>
</li>
<li><p>哈希函数：大数字在进行哈希化的代码实现放在一个函数中，这个函数称为哈希函数。</p>
</li>
<li><p>哈希表： 最终将数据插入到的这个数组，对整个结构的封装，称之为是一个哈希表。</p>
</li>
<li><p>冲突：简答理解，就是一个下标值对应了多个数据。<br>冲突不可避免，解决冲突的两种方案：<strong>（1）链地址法（拉链法）；（2）开放地址法</strong>。</p>
</li>
<li><p>链地址法：哈希槽内放置一个链表，把冲突的值放入链表中。</p>
</li>
<li><p>开放地址法：寻找空白的单元格来添加重复的数据。寻找空白位置的方法有3种：（1）线性探测；（2）二次探测；（3）再哈希法。</p>
</li>
<li><p>装填因子 = 总数据项 / 哈希表长度，因此，开放地址法的装填因子最大是1，链地址法的装填因子可以大于1。</p>
</li>
</ul>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><ul>
<li><p>好的哈希函数应该具有的优点：<br>1.快速的计算。哈希表的优势就在于效率，所以快速获取到对应的<code>HashCode</code>非常重要，提高速度的一个办法就是让哈希函数中尽量少的乘法和除法，因为它们的性能是比较低的。<br>2.均匀的分布。哈希表中，无论是链地址法还是开放地址法，当多个元素映射到同一个位置的时候，都会影响效率，所以优秀的哈希函数应该尽可能将元素映射到不同的位置，让元素在哈希表中均匀的分布。</p>
</li>
<li><p>快速计算：霍纳法则。</p>
</li>
<li><p>均匀分布：使用质数。</p>
</li>
<li><p>利用<code>ASCII</code>码值，求字符串的<code>HashCode</code>的哈希函数，如下段代码所示。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashFunction</span>(<span class="params">str, max</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//1.定义hashCode</span></span><br><span class="line">    <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.霍纳算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; str.length;i++) &#123;</span><br><span class="line">        hashCode = <span class="number">31</span> * hashCode + str.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashCode = hashCode % max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用ES6实现哈希表"><a href="#利用ES6实现哈希表" class="headerlink" title="利用ES6实现哈希表"></a>利用ES6实现哈希表</h4><p>哈希表主要包括以下几个功能：</p>
<ul>
<li><p><code>put(key, value)</code>：添加或者覆盖元素</p>
</li>
<li><p><code>get(key)</code>：通过关键值key获取value</p>
</li>
<li><p><code>remove(key)</code>：移除关键值key及value</p>
</li>
<li><p><code>resize(newLimit)</code>：哈希表的扩容或者缩小</p>
</li>
<li><p><code>isEmpty()</code>：判断是否为空</p>
</li>
<li><p><code>size()</code>：哈希表的元素数量</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = [];  <span class="comment">//数组存储元素</span></span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>; <span class="comment">//当前存放的元素个数</span></span><br><span class="line">        <span class="keyword">this</span>.limit = <span class="number">7</span>; <span class="comment">//最大存放的元素个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希函数</span></span><br><span class="line">    hashFunction(str, max) &#123;</span><br><span class="line">        <span class="comment">//1.定义hashCode</span></span><br><span class="line">        <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//2.霍纳算法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; str.length;i++) &#123;</span><br><span class="line">            hashCode = <span class="number">31</span> * hashCode + str.charCodeAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        hashCode = hashCode % max;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断质数函数</span></span><br><span class="line">    isPrime(num) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//质数必须大于1</span></span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">1</span>) &#123;   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(num === <span class="number">2</span> || num === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//不在6的倍数两侧的一定不是质数</span></span><br><span class="line">        <span class="keyword">if</span>(num % <span class="number">6</span> !== <span class="number">1</span> &amp;&amp; num % <span class="number">6</span> !== <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">let</span> temp = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(num));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//在6的倍数两侧的也不一定是质数</span></span><br><span class="line">        <span class="comment">//6n-1和6n+1不可能被2,3整除</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">5</span>; i &lt;= temp; i += <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % i === <span class="number">0</span> || num % (i + <span class="number">2</span>) ===<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getPrime(num) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!isPrime(num)) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放入或者修改元素</span></span><br><span class="line">    put(key, value) &#123;</span><br><span class="line">        <span class="comment">//1.根据key映射到下标值</span></span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.hashFunction(key, <span class="keyword">this</span>.limit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.取出数组</span></span><br><span class="line">        <span class="keyword">let</span> bucket = <span class="keyword">this</span>.storage[index];</span><br><span class="line">        <span class="keyword">if</span>(bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            bucket = [];</span><br><span class="line">            <span class="keyword">this</span>.storage[index] = bucket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断是放入还是覆盖元素</span></span><br><span class="line">        <span class="keyword">let</span> coverd = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">            <span class="keyword">if</span>(tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">                tuple[<span class="number">1</span>] = value;</span><br><span class="line">                coverd = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.如果没有覆盖，那么就是新增</span></span><br><span class="line">        <span class="keyword">if</span>(!coverd) &#123;</span><br><span class="line">            bucket.push([key, value]);</span><br><span class="line">            <span class="keyword">this</span>.count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.count &gt; <span class="keyword">this</span>.limit * MAX_LOAD_FACTOR) &#123;</span><br><span class="line">                <span class="keyword">let</span> newLimit = <span class="keyword">this</span>.limit * <span class="number">2</span>;</span><br><span class="line">                newLimit = <span class="keyword">this</span>.getPrime(newLimit);</span><br><span class="line">                <span class="keyword">this</span>.resize(newLimit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取元素，通过key获取value</span></span><br><span class="line">    <span class="keyword">get</span>(key) &#123;</span><br><span class="line">        <span class="comment">//1.首先获取下标值</span></span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.hashFunction(key, <span class="keyword">this</span>.limit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取bucket</span></span><br><span class="line">        <span class="keyword">let</span> bucket = <span class="keyword">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.遍历bucket</span></span><br><span class="line">        <span class="keyword">if</span>(bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">                <span class="keyword">if</span>(tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据key删除元素</span></span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="comment">//1.获取下标值</span></span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.hashFunction(key, <span class="keyword">this</span>.limit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取bucket</span></span><br><span class="line">        <span class="keyword">let</span> bucket = <span class="keyword">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.遍历bucket</span></span><br><span class="line">        <span class="keyword">if</span>(bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">                <span class="keyword">if</span>(tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">                    bucket.splice(i, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">this</span>.count--;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.limit &gt; <span class="number">8</span> &amp;&amp; <span class="keyword">this</span>.count &lt; <span class="keyword">this</span>.limit * MIN_LOAD_FACTOR) &#123;</span><br><span class="line">                        <span class="keyword">let</span> newLimit = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.limit / <span class="number">2</span>);</span><br><span class="line">                        newLimit = <span class="keyword">this</span>.getPrime(newLimit);</span><br><span class="line">                        <span class="keyword">this</span>.resize(newLimit);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//元素个数</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表扩容或者缩小</span></span><br><span class="line">    resize(newLimit) &#123;</span><br><span class="line">        <span class="comment">//1.保存旧的数组中的内容</span></span><br><span class="line">        <span class="keyword">let</span> oldStorage = <span class="keyword">this</span>.storage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.重置属性</span></span><br><span class="line">        <span class="keyword">this</span>.limit = newLimit;</span><br><span class="line">        <span class="keyword">this</span>.storage = [];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.取出oldStorage中所有的元素，重新放入storage</span></span><br><span class="line">        oldStorage.forEach(<span class="function"><span class="params">bucket</span> =&gt;</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(bucket === <span class="literal">undefined</span>) &#123;      <span class="comment">//其实如果是undefined,forEach压根就不会遍历这个元素</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">                <span class="keyword">this</span>.put(tuple[<span class="number">0</span>], tuple[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断一个数为质数的算法"><a href="#判断一个数为质数的算法" class="headerlink" title="判断一个数为质数的算法"></a>判断一个数为质数的算法</h4><ul>
<li>常规算法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//质数必须大于1</span></span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>) &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不是质数，则必有一个因数小于等于它的平方根</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(num));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= temp; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num % i === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>高效算法<br> 一个大于等于5的质数，一定是在6的倍数两侧的，但是反过来，6的倍数两侧并不一定是质数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//质数必须大于1</span></span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>) &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num === <span class="number">2</span> || num === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不在6的倍数两侧的一定不是质数</span></span><br><span class="line">    <span class="keyword">if</span>(num % <span class="number">6</span> !== <span class="number">1</span> &amp;&amp; num % <span class="number">6</span> !== <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(num));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在6的倍数两侧的也不一定是质数</span></span><br><span class="line">    <span class="comment">//6n-1和6n+1不可能被2,3整除</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">5</span>; i &lt;= temp; i += <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num % i === <span class="number">0</span> || num % (i + <span class="number">2</span>) ===<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法的JS实现</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
