<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS中容易混淆的一些区别</title>
    <url>/2020/05/31/CSS%E6%98%93%E6%B7%B7%E7%82%B9/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul>
<li><strong>背景图像偏移background-position中，用百分比数值和长度值的区别</strong>：<br>1.<em>用百分比数值，图像中描述为 50% 50% 的点（中心点）与元素中描述为 50% 50% 的点（中心点）对齐</em>，如果图像位于 0% 0%，其左上角将放在元素内边距区的左上角。如果图像位置是 100% 100%，会使图像的右下角放在右边距的右下角；<br>2.用长度值时，<em>长度值解释的是元素内边距区左上角的偏移</em>，偏移点是图像的左上角。<a id="more"></a>

</li>
</ul>
<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><ul>
<li><strong>text-align:center和&lt;center&gt;的区别</strong>：<br>1.text-align <em>不会控制元素的对齐，而只影响内部内容</em>，元素本身不会从一段移到另一端，只是其中的文本受影响；<br>2.&lt;center&gt;不仅影响文本，还会<em>把整个元素居中</em>。</li>
</ul>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><ul>
<li><strong>id和class的区别</strong>：<br>1.id 属性为一个元素分配一个唯一的名字，每个名字只能在被赋予的页面使用一次。（例如，假如你的页面包含 id 为 content 的 div，那么另外一个 div 或者其他别的元素都不能使用这个名字；<br>2.class 属性可以被一遍又一遍地使用在页面中（例如，页面中的五个段落都可以使用名为 “small” 或者 “footnote” 的 class 名称）；<br>3.在这个例子中，名为 searchform 的 div 被用来封装包含搜索表单的页面区域，而 div class=”blogentry” 则用来封装 blog 中的每个文章入口。因为在页面中只有一个搜索表单，所以我们选择 id 标注这个唯一的组件，但是 blog 则拥有许多的（文章）入口，所以 class 属性被应用于这种情况。同样地，新闻站点通常拥有多个 div，这些 div 的 class 可以命名为 “newsitem” 或者别的什么。 然而不是所有的站点都需要 div。blog 站点可以仅仅使用 h1 和 h2 标题和 &lt;p&gt;段落，新闻站点也一样。我们在这里展示 class 为 blogentry 的 div，并不是鼓励你在站点中塞满 div，而仅仅是为了向你展示这个原则：在同一个 HTML 文档中，使用多次 class，但只能使用一次 id。<pre><code class="html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"searchform"</span>&gt;</span>
Search form components go here. This section of the page is unique.
<span class="tag">&lt;/<span class="name">div</span>&gt;</span> 
<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blogentry"</span>&gt;</span>
  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Today's blog post<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> 
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Blog content goes here.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> 
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here is another paragraph of blog content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> 
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Just as there can be many paragraphs on a page, so too there may be many entries in a blog. A blog page could use multiple instances of the class "blogentry" (or any other class).<span class="tag">&lt;/<span class="name">p</span>&gt;</span> 
<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre>
<pre><code class="html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blogentry"</span>&gt;</span>
  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Yesterday's blog post<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>In fact, here we are inside another div of class "blogentry."<span class="tag">&lt;/<span class="name">p</span>&gt;</span>
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>They reproduce like rabbits.<span class="tag">&lt;/<span class="name">p</span>&gt;</span>
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>If there are ten blog posts on this page, there might be ten divs of class "blogentry" as well.<span class="tag">&lt;/<span class="name">p</span>&gt;</span>
<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre>
</li>
</ul>
<h4 id="边框、边距"><a href="#边框、边距" class="headerlink" title="边框、边距"></a>边框、边距</h4><ul>
<li>padding 通过百分比数值测定时，百分数值是相对于其父元素的 width 计算的，这一点与外边距一样，上下内边距与左右内边距一致，即上下内边距的百分数会相对于父元素宽度设置，而不是相对于高度。如果一个段落的父元素是div元素，那么它的内边距要根据 div 的 width 计算。</li>
</ul>
]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习小结(3)—函数</title>
    <url>/2020/06/01/JS%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>JS中函数的定义主要有以下几种方式：</p>
<ul>
<li><p><strong>函数声明</strong><br>被声明的函数不会直接执行，它们被“保存供稍后使用”，当它们被调用时执行。<strong>注意结尾引号的位置，在花括号内</strong>！Hoisting 是 JavaScript 将函数声明移动到当前作用域顶端的默认行为，正因如此，JavaScript 函数能够在声明之前被调用。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = myFunction(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>函数表达式</strong><br>函数表达式可以在变量中存储，在变量中保存函数表达式之后，此变量可用作函数，这实际上是一个匿名函数（没有名称的函数），存放在变量中的函数不需要函数名，他们总是使用变量名调用。<strong>注意结尾引号的位置，在花括号外</strong>！<strong>使用表达式定义的函数不会被提升</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a * b&#125;;</span><br><span class="line"><span class="keyword">var</span> z = x(<span class="number">4</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Function() 构造器</strong><br>函数也可以通过名为 <strong>Function()</strong> 的内建 JavaScript 函数构造器来定义。但是大多数情况下，应该避免在 JavaScript 中使用 new 关键词。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"return a * b"</span>);</span><br><span class="line"><span class="keyword">var</span> x = myFunction(<span class="number">4</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自调用函数</strong><br>函数表达式可以作为“自调用”，假如表达式后面跟着 ()，在不进行调用的情况下，函数表达式会自动执行，我们无法对函数声明进行自调用。需要在函数周围添加括号，以指示它是一个函数表达式，下例实际上是一个匿名的自调用函数（没有名称的函数）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">"Hello!!"</span>;      <span class="comment">//我会调用我自己</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>箭头函数</strong><br>1.ES6新增的方式，IE11 或更早的版本不支持箭头函数；<br>2.箭头函数允许使用简短的语法来编写函数表达式，不需要 function 关键字、return 关键字和花括号；<br>3.箭头函数没有自己的 this，它们不适合定义对象方法；<br>4.箭头函数未被提升，它们必须在使用前进行定义；<br>5.使用 const 比使用 var 更安全，因为函数表达式始终是常量值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x * y;</span><br><span class="line"><span class="keyword">var</span> a = x(<span class="number">3</span>, <span class="number">5</span>);   <span class="comment">//a = 15</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>函数是对象</strong><br>1.JavaScript 中的 typeof 运算符会为函数返回 “function”，但是最好是把 JavaScript 函数描述为对象，JavaScript 函数都有属性和方法；<br>2.定义为对象属性的函数，被称为对象的方法；<br>3.为创建新对象而设计的函数，被称为对象构造函数（对象构造器）；<br>4.toString() 方法以字符串返回函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> txt = myFunction.toString();</span><br><span class="line"><span class="comment">// txt = "function myFunction(a, b) &#123; return a * b; &#125;"</span></span><br></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4></li>
<li><p><strong>JS函数参数的规则</strong>：<br>1.函数参数（parameter）指的是在函数定义中列出的名称；<br>2.函数参数（argument）指的是传递到函数或由函数接收到的真实值；<br>3.JavaScript 函数定义不会为参数（parameter）规定数据类型；<br>4.JavaScript 函数不会对所传递的参数（argument）实行类型检查；<br>5.JavaScript 函数不会检查所接收参数（argument）的数量。</p>
</li>
<li><p>参数默认值<br>如果调用参数时省略了参数（少于被声明的数量），则丢失的值被设置为undefined，有的时候这样没问题，但最好给定默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数通过值传递<br>JavaScript 参数通过值传递：函数只知道值，而不是参数的位置，如果函数改变了参数的值，它不会改变参数的原始值，<strong>参数的改变在函数之外是不可见的</strong>。</p>
</li>
<li><p>对象是由引用传递的<br>在 JavaScript 中，对象引用是值，正因如此，对象的行为就像它们通过引用来传递，如果函数改变了对象属性，它也改变了原始值，<strong>对象属性的改变在函数之外是可见的</strong>。</p>
</li>
</ul>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>函数调用主要有下面3种方式：</p>
<ul>
<li><p><strong>以函数形式调用函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(<span class="number">10</span>, <span class="number">2</span>);           <span class="comment">// 将返回 20</span></span><br><span class="line"><span class="built_in">window</span>.myFunction(<span class="number">10</span>, <span class="number">2</span>);    <span class="comment">// 也会返回 20</span></span><br><span class="line"><span class="comment">//myFunction() 和 window.myFunction() 是同一个函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>作为方法来调用函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    firstName:<span class="string">"Bill"</span>,</span><br><span class="line">    lastName: <span class="string">"Gates"</span>,</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObject.fullName();         <span class="comment">// 将返回 "Bill Gates"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过函数构造器来调用函数</strong><br>如果函数调用的前面是 new 关键字，那么这是一个构造函数调用，它看起来像创建一个新的函数，但由于 JavaScript 函数是对象，实际上创建一个新对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是函数构造器：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = arg1;</span><br><span class="line">    <span class="keyword">this</span>.lastName  = arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个新对象：</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> myFunction(<span class="string">"Bill"</span>, <span class="string">"Gates"</span>);</span><br><span class="line">x.firstName;                             <span class="comment">// 会返回 "Bill"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="函数call"><a href="#函数call" class="headerlink" title="函数call"></a>函数call</h4><ul>
<li><p>函数是对象的方法<br>在 JavaScript 中，函数是对象的方法，如果一个函数不是 JavaScript 对象的方法，那么它就是全局对象的函数。如下例，fullName 属性是一个方法，person 对象是该方法的拥有者，fullName 属性属于 person 对象的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    firstName:<span class="string">"Bill"</span>,</span><br><span class="line">    lastName: <span class="string">"Gates"</span>,</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.fullName();		<span class="comment">// 将返回 "Bill Gates"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>call() 方法</strong><br>call() 方法是预定义的 JavaScript 方法，它可以用来调用所有者对象作为参数的方法，通过 call()，您能够使用属于另一个对象的方法，下例调用 person 的 fullName 方法，并用于 person1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    firstName:<span class="string">"Bill"</span>,</span><br><span class="line">    lastName: <span class="string">"Gates"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    firstName:<span class="string">"Steve"</span>,</span><br><span class="line">    lastName: <span class="string">"Jobs"</span>,</span><br><span class="line">&#125;</span><br><span class="line">person.fullName.call(person1);  <span class="comment">// 将返回 "Bill Gates"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>call() 方法可接受参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params">city, country</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName + <span class="string">","</span> + city + <span class="string">","</span> + country;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  firstName:<span class="string">"Bill"</span>,</span><br><span class="line">  lastName: <span class="string">"Gates"</span></span><br><span class="line">&#125;</span><br><span class="line">person.fullName.call(person1, <span class="string">"Seattle"</span>, <span class="string">"USA"</span>);</span><br><span class="line"><span class="comment">//返回Bill Gates,Seatle,USA</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="函数apply"><a href="#函数apply" class="headerlink" title="函数apply"></a>函数apply</h4><ul>
<li><p>apply() 方法与 call() 方法非常相似：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    firstName: <span class="string">"Bill"</span>,</span><br><span class="line">    lastName: <span class="string">"Gates"</span>,</span><br><span class="line">&#125;</span><br><span class="line">person.fullName.apply(person1);  <span class="comment">// 将返回 "Bill Gates"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>call() 和 apply() 之间的区别</strong>：<br>1.call() 方法分别接受参数；<br>2.apply() 方法接受数组形式的参数，如果要使用数组而不是参数列表，则 apply() 方法非常方便。</p>
</li>
<li><p>带参数的 apply() 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params">city, country</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName + <span class="string">","</span> + city + <span class="string">","</span> + country;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  firstName:<span class="string">"Bill"</span>,</span><br><span class="line">  lastName: <span class="string">"Gates"</span></span><br><span class="line">&#125;</span><br><span class="line">person.fullName.apply(person1, [<span class="string">"Seattle"</span>, <span class="string">"USA"</span>]);</span><br><span class="line"><span class="comment">//返回Bill Gates,Seatle,USA</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在数组上模拟 max 方法<br>因为可以使用 Math.max() 方法找到（数字列表中的）最大数字，而JavaScript 数组没有 max() 方法，因此可以通过apply()应用 Math.max() 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);    <span class="comment">// 会返回 3</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);   <span class="comment">// 也会返回 3</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="string">" "</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);   <span class="comment">// 也会返回 3</span></span><br><span class="line"><span class="comment">//第一个参数是无关紧要的</span></span><br></pre></td></tr></table></figure></li>
<li><p>在 JavaScript 严格模式下，如果 apply() 方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）,在“非严格”模式下，它成为全局对象。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习小结(2)—作用域</title>
    <url>/2020/05/31/JS%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h4 id="let和const的一些区别"><a href="#let和const的一些区别" class="headerlink" title="let和const的一些区别"></a>let和const的一些区别</h4><ul>
<li>let和const都是ES6新增的关键词，提供了块作用域变量；</li>
<li>通过let和const都不会被提升到顶端，也就是不能在声明之前使用；<a id="more"></a></li>
<li>使用 JavaScript 的情况下，全局作用域是 JavaScript 环境，在 HTML 中，全局作用域是 window 对象，通过 var 关键词定义的全局变量属于 window 对象，但是通过 let 和const关键词定义的全局变量不属于 window 对象；</li>
<li>const 变量必须在声明时赋值；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI; </span><br><span class="line">PI = <span class="number">3.14159265359</span>;              <span class="comment">// 这是不对的 ​​​</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14159265359</span>;       <span class="comment">//这是对的</span></span><br></pre></td></tr></table></figure></li>
<li>const 有一定的误导性，它没有定义常量值，它定义了对值的常量引用；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.141592653589793</span>; </span><br><span class="line">PI = <span class="number">3.14</span>;                    <span class="comment">// 会出错 </span></span><br><span class="line">PI = PI + <span class="number">10</span>;              <span class="comment">// 也会出错</span></span><br></pre></td></tr></table></figure></li>
<li>const可以更改常量对象的属性、常量数组的元素，但无法重新为常量对象、数组赋值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以创建 const 对象： </span></span><br><span class="line"><span class="keyword">const</span> car = &#123;<span class="attr">type</span>:<span class="string">"porsche"</span>, <span class="attr">model</span>:<span class="string">"911"</span>, <span class="attr">color</span>:<span class="string">"Black"</span>&#125;;  </span><br><span class="line"><span class="comment">// 可以更改属性： </span></span><br><span class="line">car.color = <span class="string">"White"</span>; </span><br><span class="line"><span class="comment">// 可以添加属性： </span></span><br><span class="line">car.owner = <span class="string">"Bill"</span>; </span><br><span class="line">​<span class="comment">//不可以！！！ ​​</span></span><br><span class="line">car = &#123;<span class="attr">type</span>:<span class="string">"Volvo"</span>, <span class="attr">model</span>:<span class="string">"XC60"</span>, <span class="attr">color</span>:<span class="string">"White"</span>&#125;; </span><br><span class="line">​​<span class="comment">// 您可以创建常量数组： </span></span><br><span class="line"><span class="keyword">const</span> cars = [<span class="string">"Audi"</span>, <span class="string">"BMW"</span>, <span class="string">"porsche"</span>]; </span><br><span class="line"><span class="comment">// 您可以更改元素： </span></span><br><span class="line">cars[<span class="number">0</span>] = <span class="string">"Honda"</span>; </span><br><span class="line"><span class="comment">// 您可以添加元素： </span></span><br><span class="line">cars.push(<span class="string">"Volvo"</span>); </span><br><span class="line"><span class="comment">//不可以！！！​ ​​</span></span><br><span class="line">cars = [<span class="string">"Honda"</span>, <span class="string">"Toyota"</span>, <span class="string">"Volvo"</span>];</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="JS不会为每个代码块创建新的作用域"><a href="#JS不会为每个代码块创建新的作用域" class="headerlink" title="JS不会为每个代码块创建新的作用域"></a>JS不会为每个代码块创建新的作用域</h4><ul>
<li><p>很多编程语言虽然会为每个代码块创建新的作用域，但是 JavaScript 并不会为每个代码块创建新的作用域，认为这段代码会返回 undefined是错误的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>JavaScript不会为每个代码块创建新的作用域。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>此代码将显示 i（10）的值，即使在 for 循环块之外：<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="actionscript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span></span><br><span class="line"><span class="actionscript">        &#123; <span class="comment">// some code &#125; </span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = i; </span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习小结(1)—基础</title>
    <url>/2020/05/31/JS%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>JS同时接受单引号和双引号，两种表达方式注意区分，1为双引号里套单引号，2为单引号里套双引号：<a id="more"></a>
<pre><code class="html">​<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=</span>
<span class="tag">"<span class="attr">document.getElementById</span>('<span class="attr">demo</span>')<span class="attr">.innerHTML</span> = <span class="string">'Hello JavaScript!'</span>"&gt;</span>
单击这里
<span class="tag">&lt;/<span class="name">button</span>&gt;</span>​</code></pre>
<pre><code class="html">​<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=</span>
<span class="tag">'<span class="attr">document.getElementById</span>("<span class="attr">demo</span>")<span class="attr">.innerHTML</span> = <span class="string">"Hello JavaScript!"</span>'&gt;</span>
点击这里
<span class="tag">&lt;/<span class="name">button</span>&gt;</span></code></pre>
</li>
<li>在 HTML 中，JavaScript 代码必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间，旧的 JavaScript 例子或许使用 type 属性：&lt;script type=”text/javascript”&gt;，但type 属性不是必需的，因为JavaScript 是 HTML 中的默认脚本语言。</li>
<li>能够在 HTML 文档中放置任意数量的脚本，脚本可被放置与 HTML 页面的 &lt;body&gt; 或 &lt;head&gt; 部分中，或兼而有之，<strong>但是把脚本置于 &lt;body&gt; 元素的底部，可改善显示速度，因为脚本编译会拖慢显示</strong>。</li>
<li><strong>使用外部脚本的优势</strong>：<br>1.分离了 HTML 和代码；<br>2.使 HTML 和 JavaScript 更易于阅读和维护；<br>3.已缓存的 JavaScript 文件可加速页面加载。</li>
<li>JS语言单行注释以 // 开头，不用结尾，多行注释以 /* 开头，以 */ 结尾。</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><ul>
<li><strong>数值字符串与数值相加时，前后顺序的区别</strong>：<pre><code class="html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> 
<span class="tag">&lt;<span class="name">html</span>&gt;</span>
  <span class="tag">&lt;<span class="name">body</span>&gt;</span>
    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>JavaScript 变量<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>
    <span class="tag">&lt;<span class="name">p</span>&gt;</span>相加的结果是：<span class="tag">&lt;/<span class="name">p</span>&gt;</span> 
    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> 
    ​<span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo2"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> 
    <span class="tag">&lt;<span class="name">script</span>&gt;</span> 
<span class="actionscript">      <span class="keyword">var</span> x = <span class="string">"8"</span> + <span class="number">3</span> + <span class="number">5</span>;      <span class="comment">//输出结果是835 ​</span></span>
<span class="actionscript">      <span class="keyword">var</span> y = <span class="number">3</span> + <span class="number">5</span> + <span class="string">"8"</span>       <span class="comment">//输出结果是88 </span></span>
<span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = x;       </span>
<span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"demo2"</span>).innerHTML = y;​ </span>
    <span class="tag">&lt;/<span class="name">script</span>&gt;</span> 
  <span class="tag">&lt;/<span class="name">body</span>&gt;</span> 
<span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre>
</li>
<li><strong>数字字符串，在所有数字运算中，JavaScript 会尝试将字符串转换为数字，只有+特殊，会被当作字符串串联</strong>：<pre><code class="JS"><span class="keyword">var</span> x = <span class="string">"100"</span>; 
<span class="keyword">var</span> y = <span class="string">"10"</span>; 
<span class="keyword">var</span> a = x + y;     <span class="comment">//a将是10010​ </span>
<span class="keyword">var</span> b = x - y;     <span class="comment">//a将是90 </span>
<span class="keyword">var</span> a = x * y;     <span class="comment">//a将是1000 </span>
<span class="keyword">var</span> d = x / y;     <span class="comment">//z将是 10</span></code></pre>
</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li><strong>空值与undefined不是一回事</strong>：<pre><code class="JS"><span class="keyword">var</span> car = <span class="string">""</span>;     <span class="comment">// 值是 ""，类型是 "string" 空值 ​</span>
<span class="keyword">var</span> person;     <span class="comment">// 值是 undefined，类型是 undefined</span></code></pre>
</li>
<li>在 JavaScript 中，null 是 “nothing”，它被看做不存在的事物，可以通过设置null来清空对象，但<strong>null 的数据类型是对象</strong>，undefined 与 null 的值相等，但类型不相等：<pre><code class="JS"><span class="keyword">var</span> person = <span class="literal">null</span>;     <span class="comment">// 值是 null，但是类型仍然是对象 ​</span>
<span class="keyword">typeof</span> <span class="literal">undefined</span>;    <span class="comment">// undefined</span>
<span class="keyword">typeof</span> <span class="literal">null</span>;        <span class="comment">// object </span>
<span class="literal">null</span> === <span class="literal">undefined</span>;     <span class="comment">// false </span>
<span class="literal">null</span> == <span class="literal">undefined</span>;     <span class="comment">// true</span></code></pre>
</li>
<li>字符串检索，indexOf()：从前往后检索；lastIndexOf()：从后往前检索。</li>
<li><strong>三种提取部分字符串的方法</strong>：<br>1.<strong>slice(start, end)</strong>：参数可以为负，但要注意，用负参数的时候，-1开始计数，小参数在前，大参数在后（var res = str.slice(-13,-7);），如果省略第二个参数，则该方法将裁剪字符串的剩余部分，负值位置不适用 Internet Explorer 8 及其更早版本；<br>2.<strong>substring(start, end)</strong>：会把负参数当作0，如果省略第二个参数，则该 substring() 将裁剪字符串的剩余部分；<br>3.<strong>substr(start, length)</strong>：第二个参数规定被提取部分的长度，首个参数可以为负，第二个参数不能为负，如果为负，会当作0，如果省略了第二个参数，将裁剪字符串的剩余部分。<br>4.<strong>具体的说，slice()和substring()的第二个参数都是指的最后一个字符后面的位置</strong>。</li>
<li><strong>替换字符串内容：str.replace(“a”,”b”)，用b替换str中的a</strong>：<br>1.默认地，replace() 只替换第一个匹配到的内容，如需替换所有匹配，需要使用正则表达式的 g 标志；<br>2.默认地，replace() 对大小写敏感，如需执行大小写不敏感的替换，需要使用正则表达式 /i；<br>3.使用正则表达式时不需要加引号！<pre><code class="JS">str = <span class="string">"Please visit Microsoft and Microsoft!"</span>; 
<span class="keyword">var</span> n = str.replace(<span class="regexp">/Microsoft/g</span>, <span class="string">"W3School"</span>);</code></pre>
<pre><code class="JS">str = <span class="string">"Please visit Microsoft!"</span>; 
<span class="keyword">var</span> n = str.replace(<span class="regexp">/MICROSOFT/i</span>, <span class="string">"W3School"</span>);</code></pre>
</li>
<li>ES5允许对字符串进行属性操作，但不太靠谱！<br>1.不适用 Internet Explorer 7 或更早的版本；<br>2.让字符串看起来像是数组（其实并不是），如果希望按照数组的方式处理字符串，可以用split() 将字符串转换为数组；<br>3.如果找不到字符，[ ] 返回 undefined，而 charAt() 返回空字符串；<br>4.是只读的。<pre><code class="Js"><span class="keyword">var</span> str = <span class="string">"HELLO WORLD"</span>; 
str[<span class="number">0</span>] = <span class="string">"A"</span>;     <span class="comment">// 不产生错误，但不会工作 </span>
str[<span class="number">0</span>];     <span class="comment">// 返回 H</span></code></pre>
</li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul>
<li><p>this关键词，在函数定义中，this 引用该函数的“拥有者”，在下面的例子中，this 指的是“拥有” fullName 函数的 person 对象，换言之，this.firstName 的意思是 this 对象的 firstName 属性：</p>
<pre><code class="JS"><span class="keyword">var</span> person = { 
firstName: <span class="string">"Bill"</span>, 
lastName : <span class="string">"Gates"</span>, 
id : <span class="number">678</span>, 
fullName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
<span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName; } 
};</code></pre>
</li>
<li><p>字符串可以通过关键词 new 定义为对象，<strong>但不要把字符串创建为对象，它会拖慢执行速度，数值也是同理</strong>！</p>
<pre><code class="JS"><span class="keyword">var</span> x = <span class="string">"Bill"</span>;
<span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Bill"</span>);
<span class="keyword">var</span> z = <span class="keyword">new</span> <span class="built_in">String</span>();
z = <span class="string">"Bill"</span>;
<span class="comment">// typeof x 将返回 string</span>
<span class="comment">// typeof y 将返回 object</span>
<span class="comment">// typeof z 将返回 string</span></code></pre>
</li>
<li><p><strong>js中避免使用new()！new只会使代码复杂化，还可能会产生某些不可预期的结果。</strong></p>
</li>
<li><p><strong>JavaScript 对象无法进行对比</strong>，比较两个 JavaScript 将始终返回 false：</p>
<pre><code class="JS"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Bill"</span>); 
<span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Bill"</span>); 
<span class="comment">// (x == y) 为 false，因为 x 和 y 是两个对象（对象无法比较）</span></code></pre>
</li>
<li><p><strong>不同类型值转换时易犯错的地方</strong>：<br>1.”0”：转换为布尔值为true；<br>2.””：转换为数字为0，转换为布尔值为false；<br>3.[]：转换为数字为0，字符串为””，布尔值为true；<br>4.{}：转换为数字为NaN，字符串为”[object Object]”（对象转换为字符串都是这样），布尔值为true；<br>5.null：转换为数字为0，字符串为”null”;<br>6.undefined：转换为数字为NaN，字符串为”undefined”；</p>
</li>
</ul>
<h4 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h4><ul>
<li>获取时间时，一些需要注意的地方：<br>1.getMonth() 以数字（0-11）返回日期的月份，+1才是我们的月份；<br>2.一周的第一天（0）表示“星期日”，即使世界上的一些国家认为周的第一天是“星期一”。</li>
</ul>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li>Switch case 使用的是严格比较（===），值必须与要匹配的类型相同。</li>
</ul>
]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习小结(4)—对闭包的讨论</title>
    <url>/2020/06/01/JS%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰，直观的说就是形成一个不销毁的栈环境。<br>简单理解，闭包就是一个函数引用另一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量。或者说闭包就是子函数可以使用父函数的局部变量，还有父函数的参数，即使在父函数关闭之后。这是优点也是缺点，不必要的闭包只会增加内存消耗。</p>
<a id="more"></a>
<h5 id="首先讨论一下全局变量"><a href="#首先讨论一下全局变量" class="headerlink" title="首先讨论一下全局变量"></a>首先讨论一下全局变量</h5><ul>
<li>JavaScript 变量属于本地或全局作用域，全局变量能够通过闭包实现局部（私有）。</li>
<li>全局变量需要注意的几个点：<br>1.在网页中，全局变量属于 window 对象；<br>2.拥有相同名称的全局变量和局部变量是不同的变量。修改一个，不会改变其他；<br>3.<strong>不通过关键词 var 创建的变量总是全局的，即使它们在函数中创建</strong>。</li>
<li>变量的生命周期<br>1.全局变量活得和应用程序（窗口、网页）一样久；<br>2.局部变量活得不长，它们在函数调用时创建，在函数完成后被删除。</li>
</ul>
<h5 id="JS闭包实例讨论"><a href="#JS闭包实例讨论" class="headerlink" title="JS闭包实例讨论"></a>JS闭包实例讨论</h5><ul>
<li><p>在下面的计数器例子中，变量 add 的赋值是自调用函数的返回值，这个自调用函数只运行一次，它设置counter为0，并返回函数表达，这样 add 成为了函数。</p>
</li>
<li><p>add变量可以作为一个函数使用，它能够访问父作用域中的计数器，这被称为 JavaScript 闭包，它使函数拥有“私有”变量成为可能，计数器被这个匿名函数的作用域保护，并且只能使用 add 函数来修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line"><span class="comment">// 计数器目前是 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果把add()换成add,计数器会显示：function () {counter += 1; return counter;}；</p>
</li>
<li><p><strong>为什么上面这段代码没有直接写的 function add (){…} 而是把function赋值给了变量add呢?</strong><br>1.我们通常会想当然的认为每次调用 add() 都会重走一遍add()中的代码块, 但其实不然；<br>2.注意add方法中的return, 它return的并不是1,2,3这样的数值,而是return了一个方法,并且把这个方法赋值给了add变量；<br>3.那么在这个function自运行一遍之后,其实最后赋值给add的是return counter += 1 这段代码；<br>4.所以后面每次调用add() 其实都是在调用return counter += 1，再结合之前所说的, 闭包会持有父方法的局部变量并且不会随父方法销毁而销毁, 所以这个counter其实就是来自于第一次function执行时创建的变量。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML个人学习小结</title>
    <url>/2020/05/31/HTML%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="frame框架"><a href="#frame框架" class="headerlink" title="frame框架"></a>frame框架</h3><ul>
<li><p>首先注意！frame、frameset和noframes已经从HTML5删除。</p>
</li>
<li><p>每份html文档称为一个框架，所以frameset标签将窗口分割为多个框架（即多份html文档）。</p>
<a id="more"></a></li>
<li><p>需要为不支持框架的浏览器添加&lt;noframes&gt;标签。特别注意：虽然不能将&lt;body&gt;&lt;/body&gt;标签与&lt;frameset&gt;&lt;/frameset&gt;标签同时使用，但是如果添加包含一段文本的&lt;noframes&gt;标签，就必须将这段文字嵌套于&lt;body&gt;&lt;/body&gt;标签内，参考下例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"25%,50%,25%"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"/example/html/frame_a.html"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"/example/html/frame_b.html"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"/example/html/frame_c.html"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">noframes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>您的浏览器无法处理框架！<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noframes</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>假如一个框架有可见边框，用户可以拖动边框来改变它的大小，为了避免这种情况发生，可以在标签中加入：noresize=”noresize”。如下例，a、b框架之间的边框不可调整，而b、c之间的边框仍然是可以调整的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,*,25%"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"/example/html/frame_a.html"</span> <span class="attr">noresize</span>=<span class="string">"noresize"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"/example/html/frame_b.html"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"/example/html/frame_c.html"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul>
<li><strong>HTML中”bgcolor”与”background-color”的区别</strong>：<br>bgcolor只是标签属性，而backgroud更多作为css的样式属性，它们俩大多数情况下效果完全相同。但在&lt;p&gt;标签下效果不同，&lt;p&gt;不支持bgcolor属性，只能用style标签添加CSS样式。</li>
<li><strong>padding和margin的区别</strong>：<br>padding是指该元素边框线以内的距离，设定之后，该元素内部的非漂浮或定位元素都会距离该元素的边框距离该设定的值的长度，不可以设置负值，不报错，但没有效果；margin是指该元素边框线以外的距离，设定之后，该元素的外边距离所设置方向的元素会相应增加或减少，可以设置负值，会向相反方向移动。</li>
</ul>
<h3 id="script脚本"><a href="#script脚本" class="headerlink" title="script脚本"></a>script脚本</h3><ul>
<li><p>&lt;noscript&gt;标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本。&lt;noscript&gt;元素可包含普通 HTML 页面的 body 元素中能够找到的所有元素。只有在浏览器不支持脚本或者禁用脚本时，才会显示noscript元素中的内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">"Hello World!"</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span>Sorry, your browser does not support JavaScript!<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>不支持 JavaScript 的浏览器将显示 noscript 元素中的文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><strong>如何应对老式浏览器</strong>：<br>如果浏览器压根没法识别&lt;script&gt;标签，那么&lt;script&gt;标签所包含的内容将以文本方式显示在页面上。为了避免这种情况发生，应该将脚本隐藏在注释标签当中。那些老的浏览器（无法识别&lt;script&gt;标签的浏览器）将忽略这些注释，所以不会将标签的内容显示到页面上。而那些新的浏览器将读懂这些脚本并执行它们，即使代码被嵌套在注释标签内：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">&lt;!-- </span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">"Hello World!"</span>) </span></span><br><span class="line"><span class="actionscript"><span class="comment">//--&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>支持script标签 的浏览器将显示script元素中的文本，不支持的则不会显示"Hello World!"。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="input输入"><a href="#input输入" class="headerlink" title="input输入"></a>input输入</h3><ul>
<li><strong>size与maxlength的关系</strong>：<br>size设定文本框的长度，对内容输入长度无限制，maxlength设定文本的最大输入长度。如果size的值小于maxlength的值，当内容超过窗口的长度时会自动滚动；如果size的值大于maxlength的值，超过maxlength长度的内容无法输入。</li>
<li>&lt;form target=”_blank&gt;，在&lt;input type=”submit”&gt;元素里输入target属性是无效的，应该用formtarget，并且formtarget属性会覆盖&lt;form&gt;元素的target属性。</li>
<li><strong>method中get和post的区别</strong>：<br>get：（1）是form默认的提交方式 ；（2）如果通过一个超链访问某个地址，是get方式 ；（3）如果在地址栏直接输入某个地址，是get方式 ；（4）提交数据会在浏览器显示出来 ，保密性差，所以不如post安全；（5）不可以用于提交二进制数据，比如上传文件 。<br>post：（1） 必须在form上通过method=”post” 显式指定 ；（2）提交数据不会在浏览器显示出来 ；（3）适合提交大量数据，可以用于提交二进制数据，比如上传文件。</li>
</ul>
<h3 id="音频、视频问题总结"><a href="#音频、视频问题总结" class="headerlink" title="音频、视频问题总结"></a>音频、视频问题总结</h3><ul>
<li><p>iPhone、iPad不能显示Flash视频。</p>
</li>
<li><p><strong>&lt;object&gt;和&lt;embed&gt;的区别</strong>：<br>（1）&lt;object&gt;标签是 HTML 4 的标准标签（在HTML 5中依然保留，但是删除了部分属性），&lt;embed&gt;标签是 HTML 5 的新标签，不支持HTML4（新生代，但是老版本的浏览器可能不认识它）；（2）功能上没有太大区别；（3）浏览器兼容性区别：IE只支持对Object的解析；火狐，谷歌，Safari只支持对Embed的解析；（4）格式上的区别：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">​<span class="tag">&lt;<span class="name">embed</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">src</span>=<span class="string">"/i/bookmark.swf"</span> /&gt;</span></span><br><span class="line">​<span class="tag">&lt;<span class="name">object</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">data</span>=<span class="string">"/i/bookmark.swf"</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;audio&gt;和&lt;video&gt;支持所有浏览器，不支持HTML4，在老式浏览器是无效的。</p>
</li>
<li><p><strong>音频最好的解决方法</strong>：<br>HTML 5 + &lt;object&gt; + &lt;embed&gt;（为什么添加两种格式的音频？因为使用了一个 mp3 文件，这样它在 Internet Explorer、Chrome 以及 Safari 中是有效的，为了使这段音频在 Firefox 和 Opera 中同样有效，添加了一个 ogg 类型的文件）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"/i/song.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"/i/song.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mp3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">data</span>=<span class="string">"/i/horse.mp3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">src</span>=<span class="string">"/i/song.mp3"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objiect</span>&gt;</span>​</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>音频最简单的解决方法</strong>：JavaScript嵌入雅虎播放器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/i/song.mp3"</span>&gt;</span>播放 mp3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"[http://mediaplayer.yahoo.com/js](http://mediaplayer.yahoo.com/js)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><strong>视频最好的解决方法</strong>：HTML 5 + &lt;object&gt; + &lt;embed&gt;。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.webm"</span> <span class="attr">type</span>=<span class="string">"video/webm"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">"movie.mp4"</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">"movie.swf"</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="output输出"><a href="#output输出" class="headerlink" title="output输出"></a>output输出</h3><ul>
<li><p>W3school上面的output例子不是特别好，应用比较复杂，可以参考下面这一个例子:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>在线计算器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">oninput</span>=<span class="string">"x.value=parseInt(a.value)+parseInt(b.value)"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span> + </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span> = </span><br><span class="line">    <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">"x"</span> <span class="attr">for</span>=<span class="string">"a b"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>注意:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> Edge 12及更早 IE 版本的浏览器不支持 output 元素。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-变量的解构赋值</title>
    <url>/2020/06/17/ES6%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><ul>
<li>如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。<a id="more"></a>

</li>
</ul>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><ul>
<li>只有当一个数组成员严格等于undefined，默认值才会生效。下面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><ul>
<li>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</li>
<li>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure></li>
<li>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</li>
<li>）如果要将一个已经声明的变量用于解构赋值，必须非常小心。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure></li>
<li>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></li>
<li>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行</li>
</ul>
<h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><ul>
<li>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br></pre></td></tr></table></figure></li>
<li>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="圆括号的问题"><a href="#圆括号的问题" class="headerlink" title="圆括号的问题"></a>圆括号的问题</h3><h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><ul>
<li>变量声明语句<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure></li>
<li>函数参数<br>函数参数也属于变量声明，因此不能带有圆括号。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x</span>)]) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure></li>
<li>赋值语句的模式<br>下面代码将整个模式放在圆括号之中，导致报错。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><ul>
<li>可以使用圆括号的情况只有一种：<strong>赋值语句的非模式部分</strong>，可以使用圆括号。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
<li>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</li>
</ul>
<h3 id="变量的解构赋值用途"><a href="#变量的解构赋值用途" class="headerlink" title="变量的解构赋值用途"></a>变量的解构赋值用途</h3><ul>
<li>交换变量的值<br>下面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></li>
<li>从函数返回多个值<br>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure></li>
<li>函数参数的定义<br>解构赋值可以方便地将一组参数与变量名对应起来。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></li>
<li>提取 JSON 数据<br>解构赋值对提取 JSON 对象中的数据，尤其有用，下面代码可以快速提取 JSON 数据的值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure></li>
<li>函数参数的默认值<br>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>遍历 Map 结构<br>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure></li>
<li>输入模块的指定方法<br>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ES6学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-let和const</title>
    <url>/2020/06/17/ES6%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><ul>
<li>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<a id="more"></a></li>
<li>下面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure></li>
<li>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>
</ul>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><ul>
<li>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure></li>
<li>如果想将对象冻结，可以使用Object.freeze方法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><ul>
<li>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。<br>1.浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。<br>2.浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。<br>3.Node 里面，顶层对象是global，但其他环境都不支持。</li>
<li>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。<br>1.全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。<br>2.函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。<br>3.不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。</li>
</ul>
]]></content>
      <categories>
        <category>ES6学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>setTimeOut()和setInterval()讨论</title>
    <url>/2020/06/17/%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在学到setTimeOut()和setInterval()时，遇到这两个函数调用函数为什么不加括号的问题，以setTimeOut()为例，做了小测试，总结如下。</p>
<a id="more"></a>

<h4 id="当调用函数不加-时"><a href="#当调用函数不加-时" class="headerlink" title="当调用函数不加()时"></a>当调用函数不加()时</h4><ul>
<li>不加括号，网页会在3秒后弹出警告框，证明定时器起作用了。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">my</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"执行！"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    setTimeout(my, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="当调用函数加上-时"><a href="#当调用函数加上-时" class="headerlink" title="当调用函数加上()时"></a>当调用函数加上()时</h4><ul>
<li>加上括号，网页立即弹出警告框，证明定时器没起作用。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">my</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"执行！"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    setTimeout(my(), <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>使用定时器时，调度权没有在我们自己手里，而是定时器自己去间隔调用的。</li>
<li>加括号为调用该函数，返回值为函数返回值，而定时器是结合函数引用进行调度的，并不是函数的执行返回结果。</li>
<li>加括号时，可以加” “解决问题。</li>
</ul>
]]></content>
      <categories>
        <category>JS高级程序设计</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝与深拷贝</title>
    <url>/2020/06/17/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h4 id="深拷贝和浅拷贝简单解释"><a href="#深拷贝和浅拷贝简单解释" class="headerlink" title="深拷贝和浅拷贝简单解释"></a>深拷贝和浅拷贝简单解释</h4><ul>
<li>浅拷贝和深拷贝都<strong>只针对于引用数据类型</strong>。</li>
<li>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</li>
<li>深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。<a id="more"></a>

</li>
</ul>
<h4 id="如何区分深拷贝与浅拷贝"><a href="#如何区分深拷贝与浅拷贝" class="headerlink" title="如何区分深拷贝与浅拷贝"></a>如何区分深拷贝与浅拷贝</h4><ul>
<li>简单点来说，假设B复制了A，当修改B时，看A是否会发生变化，如果A也跟着变了，说明这是浅拷贝，如果A没变，那就是深拷贝。</li>
</ul>
<h4 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h4><h5 id="直接用-赋值"><a href="#直接用-赋值" class="headerlink" title="直接用=赋值"></a>直接用=赋值</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[2, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[2, 2]</span></span><br></pre></td></tr></table></figure>

<h5 id="Object-assign方法"><a href="#Object-assign方法" class="headerlink" title="Object.assign方法"></a>Object.assign方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,[<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(a);</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[9, [2, 9]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[9, [2, 9]]</span></span><br></pre></td></tr></table></figure>

<h4 id="一层深拷贝的浅拷贝的实现"><a href="#一层深拷贝的浅拷贝的实现" class="headerlink" title="一层深拷贝的浅拷贝的实现"></a>一层深拷贝的浅拷贝的实现</h4><h5 id="扩展运算符方法"><a href="#扩展运算符方法" class="headerlink" title="扩展运算符方法"></a>扩展运算符方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = [...a];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[1, [2, 9]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[9, [2, 9]]</span></span><br></pre></td></tr></table></figure>

<h5 id="concat方法"><a href="#concat方法" class="headerlink" title="concat方法"></a>concat方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = a.concat();</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[1, [2, 9]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[9, [2, 9]]</span></span><br></pre></td></tr></table></figure>

<h5 id="slice方法"><a href="#slice方法" class="headerlink" title="slice方法"></a>slice方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = a.slice(<span class="number">0</span>);</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[1, [2, 9]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[9, [2, 9]]</span></span><br></pre></td></tr></table></figure>

<h5 id="Object-assign方法赋值给一个空对象"><a href="#Object-assign方法赋值给一个空对象" class="headerlink" title="Object.assign方法赋值给一个空对象"></a>Object.assign方法赋值给一个空对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,[<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign([], a);</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[1, [2, 9]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[9, [2, 9]]</span></span><br></pre></td></tr></table></figure>

<h4 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Array</span>.isArray(a) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">"object"</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.hasOwnProperty(i)) &#123;</span><br><span class="line">          <span class="comment">// 如果子属性为引用数据类型，递归复制</span></span><br><span class="line">          <span class="keyword">if</span> (a[i] &amp;&amp; <span class="keyword">typeof</span> a[i] === <span class="string">"object"</span>) &#123;</span><br><span class="line">            b[i] = deepCopy(a[i]);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是基本数据类型，只是简单的复制</span></span><br><span class="line">            b[i] = a[i];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = deepCopy(a);</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[1, [2, 3]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[9, [2, 9]]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS高级程序设计</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES5</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-Symbol</title>
    <url>/2020/06/20/ES6%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（<code>Boolean</code>）、字符串（<code>String</code>）、数值（<code>Number</code>）、对象（<code>Object</code>）。</li>
<li>凡是属性名属于<code>Symbol</code>类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 <code>Symbol</code>实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol</code>函数的参数只是表示对当前 <code>Symbol</code> 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol</code> 值不能与其他类型的值进行运算，会报错。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">"your symbol is "</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol</code> 值可以显式转为字符串，也可以转为布尔值，但是不能转为数值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(sym) <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(sym) <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h3><ul>
<li>ES2019提供了一个实例属性<code>description</code>，直接返回 <code>Symbol</code> 的描述。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line">sym.description <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h3><ul>
<li>将对象的属性名指定为一个 <code>Symbol</code> 值，有以下3种方式。如果mySymbol不放在方括号中，该属性的键名就是字符串mySymbol，而不是mySymbol所代表的那个 <code>Symbol</code> 值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br><span class="line">a.mySymbol  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol</code> 值作为对象属性名时，不能用点运算符。下面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 <code>Symbol</code> 值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">'Hello!'</span>;</span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">'mySymbol'</span>] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h3><p>针对<code>Symbol</code>属性名，有两种遍历方式。</p>
<ul>
<li><code>Object.getOwnPropertySymbols()</code> 方法，可以获取指定对象的所有 <code>Symbol</code> 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 <code>Symbol</code> 值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure></li>
<li>一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 <code>Symbol</code> 键名。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"><span class="comment">//  ["enum", "nonEnum", Symbol(my_key)]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h3><ul>
<li><code>Symbol.for()</code>方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。如果有，就返回这个 <code>Symbol</code> 值，否则就新建一个以该字符串为名称的 <code>Symbol</code> 值，并将其注册到全局。</li>
<li>上面代码中，s1和s2都是 <code>Symbol</code> 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 <code>Symbol</code>。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 <code>Symbol</code> 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(“cat”) 30 次，每次都会返回同一个 <code>Symbol</code> 值，但是调用 <code>Symbol</code>(“cat”) 30 次，会返回 30 个不同的 <code>Symbol</code> 值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li><code>Symbol.keyFor()</code>方法返回一个已登记的 <code>Symbol</code> 类型值的<code>key</code>。下面代码中，变量s2属于未登记的 <code>Symbol</code> 值，所以返回<code>undefined</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
<li>注意，<code>Symbol.for()</code>为 <code>Symbol</code> 值登记的名字，是全局环境的，不管有没有在全局环境运行。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = foo();</span><br><span class="line"><span class="keyword">const</span> y = <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x === y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h3><p>ES6 还提供了 11 个内置的 <code>Symbol</code> 值，指向语言内部使用的方法。（未完全列举）</p>
<h4 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h4><ul>
<li>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。</li>
<li>下面代码中，MyClass是一个类，new MyClass()会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.hasInstance](foo) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> MyClass() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h4><ul>
<li>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr1, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br><span class="line">arr1[<span class="built_in">Symbol</span>.isConcatSpreadable] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr2, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', ['c','d'], 'e']</span></span><br></pre></td></tr></table></figure></li>
<li>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</li>
<li>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'c'</span>, <span class="number">1</span>: <span class="string">'d'</span>&#125;;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', obj, 'e']</span></span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h4><ul>
<li>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</li>
<li>下面代码中，a.map(x =&gt; x)生成的衍生对象，就不是MyArray的实例，而直接就是<code>Array</code>的实例。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> MyArray();</span><br><span class="line"><span class="keyword">const</span> b = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> MyArray <span class="comment">// false</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h4><ul>
<li>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.match(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="built_in">Symbol</span>.match](<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMatcher</span> </span>&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.match](string) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span>.indexOf(string);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'e'</span>.match(<span class="keyword">new</span> MyMatcher()) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ES6学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-数据结构新增的方法</title>
    <url>/2020/06/20/ES6%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h3 id="字符串新增的方法"><a href="#字符串新增的方法" class="headerlink" title="字符串新增的方法"></a>字符串新增的方法</h3><h4 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h4><p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p>
<a id="more"></a>
<ul>
<li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li>
<li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line">s.startsWith(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'!'</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>这三个方法都支持第二个参数，表示开始搜索的位置。但是需要注意，使用第二个参数n时，<code>endsWith</code>的行为与其他两个方法有所不同，它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><ul>
<li><code>repeat()</code>方法返回一个新字符串，表示将原字符串重复n次。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span></span><br><span class="line"><span class="comment">//参数如果是小数，会被取整。</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>) <span class="comment">// "nana"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h4><ul>
<li>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</li>
<li>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="trimStart-，trimEnd"><a href="#trimStart-，trimEnd" class="headerlink" title="trimStart()，trimEnd()"></a>trimStart()，trimEnd()</h4><ul>
<li>这两个方法与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">'  abc  '</span>;</span><br><span class="line"></span><br><span class="line">s.trim() <span class="comment">// "abc"</span></span><br><span class="line">s.trimStart() <span class="comment">// "abc  "</span></span><br><span class="line">s.trimEnd() <span class="comment">// "  abc"</span></span><br></pre></td></tr></table></figure></li>
<li>除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</li>
</ul>
<h3 id="数值新增的方法"><a href="#数值新增的方法" class="headerlink" title="数值新增的方法"></a>数值新增的方法</h3><h4 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h4><ul>
<li><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite），即不是Infinity。<strong>注意，如果参数类型不是数值，<code>Number.isFinite</code>一律返回false。</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">15</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'foo'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'15'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li><code>Number.isNaN()</code>用来检查一个值是否为NaN。<strong>如果参数类型不是NaN，<code>Number.isNaN</code>一律返回false。</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span> / <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span> / <span class="string">'true'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><strong>与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于</strong>，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，<code>Number.isFinite()</code>对于非数值一律返回false, <code>Number.isNaN()</code>只有对于NaN才返回true，非NaN一律返回false。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">"25"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">"25"</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"NaN"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"NaN"</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><ul>
<li><code>Number.isInteger()</code>用来判断一个数值是否为整数。</li>
<li>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>如果参数不是数值，<code>Number.isInteger</code>返回false。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger() <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h4><ul>
<li><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-4.1</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-4.9</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-0.1234</span>) <span class="comment">// -0</span></span><br></pre></td></tr></table></figure></li>
<li>对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'123.456'</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">true</span>) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">null</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li>
<li>对于空值和无法截取整数的值，返回NaN。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">NaN</span>);      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'foo'</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc();         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数组新增的方法"><a href="#数组新增的方法" class="headerlink" title="数组新增的方法"></a>数组新增的方法</h3><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><ul>
<li>扩展运算符（spread）是三个点（…）,它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure></li>
<li>该运算符主要用于函数调用。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure></li>
<li>注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。下面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(...[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((...[<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="替代apply函数"><a href="#替代apply函数" class="headerlink" title="替代apply函数"></a>替代apply函数</h5><ul>
<li>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure></li>
<li>应用到<code>Math.max</code>方法，简化求出一个数组最大元素的写法。下面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用 <code>Math.max</code>函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用<code>Math.max</code>了。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure></li>
<li>通过<code>push</code>函数，将一个数组添加到另一个数组的尾部。下面代码的 ES5 写法中，<code>push</code>方法的参数不能是数组，所以只好通过<code>apply</code>方法变通使用<code>push</code>方法。有了扩展运算符，就可以直接将数组传入<code>push</code>方法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5的 写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h5><ul>
<li>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。下面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure></li>
<li>ES5 只能用变通方法来复制数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure></li>
<li>扩展运算符提供了复制数组的简便写法，下面的两种写法，a2都是a1的克隆。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h5><ul>
<li>扩展运算符提供了数组合并的新写法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="与解构赋值结合"><a href="#与解构赋值结合" class="headerlink" title="与解构赋值结合"></a>与解构赋值结合</h5><ul>
<li>扩展运算符可以与解构赋值结合起来，用于生成数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br></pre></td></tr></table></figure></li>
<li>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><ul>
<li>扩展运算符还可以将字符串转为真正的数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line"><span class="comment">// [ "h", "e", "l", "l", "o" ]</span></span><br></pre></td></tr></table></figure></li>
<li>下面代码的第一种写法，JavaScript 会将四个字节的 <code>Unicode</code> 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'x\uD83D\uDE80y'</span>.length <span class="comment">// 4</span></span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...str].length;</span><br><span class="line">&#125;</span><br><span class="line">length(<span class="string">'x\uD83D\uDE80y'</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="实现了-Iterator-接口的对象"><a href="#实现了-Iterator-接口的对象" class="headerlink" title="实现了 Iterator 接口的对象"></a>实现了 Iterator 接口的对象</h5><ul>
<li>任何定义了遍历器（<code>Iterator</code>）接口的对象，都可以用扩展运算符转为真正的数组。下面代码中，<code>querySelectorAll</code>方法返回的是一个<code>NodeList</code>对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了 <code>Iterator</code> 。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="Map-和-Set-结构，Generator-函数"><a href="#Map-和-Set-结构，Generator-函数" class="headerlink" title="Map 和 Set 结构，Generator 函数"></a>Map 和 Set 结构，Generator 函数</h5><ul>
<li>扩展运算符内部调用的是数据结构的 <code>Iterator</code> 接口，因此只要具有 <code>Iterator</code> 接口的对象，都可以使用扩展运算符，比如 <code>Map</code> 结构。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><ul>
<li><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（<code>array-like object</code>）和可遍历（<code>iterable</code>）的对象（包括 ES6 新增的数据结构 <code>Set</code> 和 <code>Map</code>）。下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><ul>
<li><code>Array.of</code>方法用于将一组值，转换为数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
<li>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。下面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find() 和 findIndex()"></a>find() 和 findIndex()</h4><ul>
<li>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure></li>
<li>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
<li>这两个方法都可以发现NaN，弥补了数组的<code>indexOf</code>方法的，下面代码中，<code>indexOf</code>方法无法识别数组的NaN成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><ul>
<li><code>fill</code>方法使用给定值，填充一个数组。数组中已有的元素，会被全部抹去。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure></li>
<li><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure></li>
<li>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123;<span class="attr">name</span>: <span class="string">"Mike"</span>&#125;);</span><br><span class="line">arr[<span class="number">0</span>].name = <span class="string">"Ben"</span>;</span><br><span class="line">arr</span><br><span class="line"><span class="comment">// [&#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="entries-，keys-和-values"><a href="#entries-，keys-和-values" class="headerlink" title="entries()，keys() 和 values()"></a>entries()，keys() 和 values()</h4><ul>
<li>用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br></pre></td></tr></table></figure></li>
<li>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="include"><a href="#include" class="headerlink" title="include()"></a>include()</h4><ul>
<li>返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。includes使用的是不一样的判断算法，就没有这个问题。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>严格相等运算符（===）的NaN不等于自身。</li>
</ul>
<h4 id="flat-，flatMap"><a href="#flat-，flatMap" class="headerlink" title="flat()，flatMap()"></a>flat()，flatMap()</h4><ul>
<li>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li>
<li><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</li>
<li><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组，只能展开一层数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h4><ul>
<li>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位，下面代码中，Array(3)返回一个具有 3 个空位的数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure></li>
<li>注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。下面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>ES5 对空位的处理，很不一致，大多数情况下会忽略空位。<br>1.<code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code>和<code>some()</code>都会跳过空位。<br>2.<code>map()</code>会跳过空位，但会保留这个值<br>3.<code>join()</code>和<code>toString()</code>会将空位视为undefined，而<code>undefined</code>和<code>null</code>会被处理成空字符串。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach方法</span></span><br><span class="line">[,<span class="string">'a'</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter方法</span></span><br><span class="line">[<span class="string">'a'</span>,,<span class="string">'b'</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// ['a','b']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every方法</span></span><br><span class="line">[,<span class="string">'a'</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce方法</span></span><br><span class="line">[<span class="number">1</span>,,<span class="number">2</span>].reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some方法</span></span><br><span class="line">[,<span class="string">'a'</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map方法</span></span><br><span class="line">[,<span class="string">'a'</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join方法</span></span><br><span class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">'#'</span>) <span class="comment">// "#a##"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString方法</span></span><br><span class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].toString() <span class="comment">// ",a,,"</span></span><br></pre></td></tr></table></figure></li>
<li><strong>ES6 则是明确将空位转为undefined。</strong></li>
</ul>
<h3 id="对象新增的方法"><a href="#对象新增的方法" class="headerlink" title="对象新增的方法"></a>对象新增的方法</h3><h4 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h4><ul>
<li>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure></li>
<li>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性，这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。<br>1.<code>for...in</code>：只遍历对象自身的和继承的可枚举的属性。<br>2.<code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。<br>3.<code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。<br>4.<code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>
<li>引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被for…in遍历到。下面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">'toString'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor([], <span class="string">'length'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><ul>
<li><strong>for…in</strong><br><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含<code>Symbol</code> 属性）。</li>
<li><strong>Object.keys(obj)</strong><br><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 <code>Symbol</code> 属性）的键名。</li>
<li><strong>Object.getOwnPropertyNames(obj)</strong><br><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含<code>Symbol</code>属性，但是包括不可枚举属性）的键名。</li>
<li><strong>Object.getOwnPropertySymbols(obj)</strong><br><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 <code>Symbol</code>属性的键名。</li>
<li><strong>Reflect.ownKeys(obj)</strong><br><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 <code>Symbol</code> 或字符串，也不管是否可枚举。</li>
<li>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。首先遍历所有数值键，按照数值升序排列。其次遍历所有字符串键，按照加入时间升序排列。最后遍历所有 <code>Symbol</code> 键，按照加入时间升序排列。</li>
</ul>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><ul>
<li><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。下面代码中，对象<code>obj.find()</code>方法之中，通过super.foo引用了原型对象proto的foo属性。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'world'</span>,</span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure></li>
<li>JavaScript 引擎内部，super.foo等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。下面代码中，super.foo指向原型对象proto的foo方法，但是绑定的<code>this</code>却还是当前对象obj，因此输出的就是world。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  x: <span class="string">'hello'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x: <span class="string">'world'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// "world"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><ul>
<li>用来比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>不同之处只有两个：<strong>一是+0不等于-0，二是NaN等于自身。</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><ul>
<li><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><ul>
<li><strong>浅拷贝</strong>，可详细参考<a href="https://starkmage.github.io/2020/06/17/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/#more" target="_blank" rel="noopener">浅拷贝与深拷贝</a>。</li>
<li><strong>同名属性的替换</strong>。对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加。下面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{ a: { b: ‘hello’, d: ‘e’ } }的结果。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span>, <span class="attr">d</span>: <span class="string">'e'</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: 'hello' &#125; &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>数组的处理</strong>。<code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。下面代码中，Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure></li>
<li><strong>取值函数的处理</strong>。Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。下面代码中，source对象的foo属性是一个取值函数，Object.assign不会复制这个取值函数，只会拿到值以后，将这个值复制过去。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">get</span> foo() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h4><ul>
<li>ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</li>
<li>下面代码中，<code>Object.getOwnPropertyDescriptors()</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> bar() &#123; <span class="keyword">return</span> <span class="string">'abc'</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><ul>
<li><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（<code>prototype</code>），返回参数对象本身，它是 ES6 正式推荐的设置原型对象的方法。</li>
<li>下面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><ul>
<li>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rec = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(rec, <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h4><ul>
<li>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（1enumerable`）属性的键名。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="comment">// ["foo", "baz"]</span></span><br></pre></td></tr></table></figure></li>
<li>ES2017 引入了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log([key, value]); <span class="comment">//[ ['a', 1], ['b', 2], ['c', 3] ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h4><ul>
<li><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">  [<span class="string">'baz'</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><ul>
<li>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li>
<li>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line">f(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br></pre></td></tr></table></figure></li>
<li>指定了默认值以后，函数的 <code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><ul>
<li>如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;)</span><br></pre></td></tr></table></figure></li>
<li><strong>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</strong></li>
</ul>
]]></content>
      <categories>
        <category>ES6学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-Set和Map</title>
    <url>/2020/06/20/ES6%E7%AC%94%E8%AE%B05/</url>
    <content><![CDATA[<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>ES6 提供了新的数据结构 <code>Set</code>，它类似于数组，但是成员的值都是唯一的，没有重复的值。<code>Set</code> 本身是一个构造函数，用来生成 <code>Set</code> 数据结构。<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure></li>
<li><code>Set</code>函数可以接受一个数组（或者具有 <code>iterable</code> 接口的其他数据结构）作为参数，用来初始化。注意，<code>Set</code>数据结构没有 <code>length</code>，用的是 <code>size</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...<span class="keyword">set</span>]</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);</span><br><span class="line">items.size // 5</span><br></pre></td></tr></table></figure></li>
<li><strong>向 <code>Set</code> 加入值的时候，不会发生类型转换</strong>，所以5和”5”是两个不同的值。<code>Set</code> 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），<strong>主要的区别是向 <code>Set</code> 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身</strong>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">let a = NaN;</span><br><span class="line">let b = NaN;</span><br><span class="line"><span class="keyword">set</span>.add(a);</span><br><span class="line"><span class="keyword">set</span>.add(b);</span><br><span class="line"><span class="keyword">set</span> // Set &#123;<span class="literal">NaN</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>两个对象总是不相等的。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;);</span><br><span class="line"><span class="keyword">set</span>.size // 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;);</span><br><span class="line"><span class="keyword">set</span>.size // 2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h6><ul>
<li><code>Set.prototype.add(value)</code>：添加某个值，返回 <code>Set</code> 结构本身。</li>
<li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.size <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.has(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="number">2</span>);</span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h6><ul>
<li><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象。由于 <code>Set</code> 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"></span><br><span class="line">for (let item of <span class="keyword">set</span>.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["red", "red"]</span></span><br><span class="line"><span class="comment">// ["green", "green"]</span></span><br><span class="line"><span class="comment">// ["blue", "blue"]</span></span><br></pre></td></tr></table></figure></li>
<li>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</li>
<li><code>Set</code> 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 <code>Set</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"></span><br><span class="line">for (let x of <span class="keyword">set</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure></li>
<li><code>Set</code> 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 4, 9]);</span><br><span class="line"><span class="keyword">set</span>.forEach((value, key) =&gt; console.log(key + ' : ' + value))</span><br><span class="line">// 1 : 1</span><br><span class="line">// 4 : 4</span><br><span class="line">// 9 : 9</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><h4 id="与Set区别"><a href="#与Set区别" class="headerlink" title="与Set区别"></a>与Set区别</h4><ul>
<li><code>WeakSet</code> 结构与 <code>Set</code> 类似，也是不重复的值的集合。但是，它与 <code>Set</code> 有两个区别。<br>1.<code>WeakSet</code> 的成员只能是对象，而不能是其他类型的值；<br>2.<code>WeakSet</code> 中的对象都是弱引用，即垃圾回收机制不考虑 <code>WeakSet</code> 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code>WeakSet</code> 之中。</li>
</ul>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li><code>WeakSet</code> 是一个构造函数，可以使用<code>new</code>命令，创建 <code>WeakSet</code> 数据结构。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br></pre></td></tr></table></figure></li>
<li>下面代码中，a是一个数组，它有两个成员，也都是数组。将a作为 <code>WeakSet</code> 构造函数的参数，a的成员会自动成为 <code>WeakSet</code> 的成员。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>注意，是a数组的成员成为 <code>WeakSet</code> 的成员，而不是a数组本身。这意味着，数组的成员只能是对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(b);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Invalid value used in weak set(…)</span></span><br></pre></td></tr></table></figure></li>
<li><code>WeakSet.prototype.add(value)</code>：向 <code>WeakSet</code> 实例添加一个新成员。</li>
<li><code>WeakSet.prototype.delete(value)</code>：清除 <code>WeakSet</code> 实例的指定成员。</li>
<li><code>WeakSet.prototype.has(value)</code>：返回一个布尔值，表示某个值是否在 <code>WeakSet</code> 实例之中。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.add(<span class="built_in">window</span>);</span><br><span class="line">ws.add(obj);</span><br><span class="line"></span><br><span class="line">ws.has(<span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">ws.has(foo);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">ws.delete(<span class="built_in">window</span>);</span><br><span class="line">ws.has(<span class="built_in">window</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li><code>WeakSet</code> 没有<code>size</code>属性，没有办法遍历它的成员。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.size <span class="comment">// undefined</span></span><br><span class="line">ws.forEach <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">ws.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'WeakSet has '</span> + item)&#125;)</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li><code>Map</code> 数据结构类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，<code>Object</code> 结构提供了“字符串—值”的对应，<code>Map</code> 结构提供了“值—值”的对应，是一种更完善的 <code>Hash</code> 结构实现。</li>
<li>作为构造函数，<code>Map</code> 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'name'</span>) <span class="comment">// "张三"</span></span><br><span class="line">map.has(<span class="string">'title'</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'title'</span>) <span class="comment">// "Author"</span></span><br></pre></td></tr></table></figure></li>
<li><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">items.forEach(</span><br><span class="line">  ([key, value]) =&gt; map.set(key, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>如果对同一个键多次赋值，后面的值将覆盖前面的值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(<span class="number">1</span>, <span class="string">'aaa'</span>)</span><br><span class="line">.set(<span class="number">1</span>, <span class="string">'bbb'</span>);</span><br><span class="line"></span><br><span class="line">map.get(<span class="number">1</span>) <span class="comment">// "bbb"</span></span><br></pre></td></tr></table></figure></li>
<li>只有对同一个对象的引用，<code>Map</code> 结构才将其视为同一个键。下面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">'a'</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
<li>同理，同样的值的两个实例，在 <code>Map</code> 结构中被视为两个键。下面代码中，变量k1和k2的值是一样的，但是它们在 <code>Map</code> 结构中被视为两个键。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, <span class="number">111</span>)</span><br><span class="line">.set(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">map.get(k1) <span class="comment">// 111</span></span><br><span class="line">map.get(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure></li>
<li>由上可知，<code>Map</code> 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</li>
</ul>
<h4 id="Map实例的属性和操作方法"><a href="#Map实例的属性和操作方法" class="headerlink" title="Map实例的属性和操作方法"></a>Map实例的属性和操作方法</h4><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><ul>
<li><code>size</code>属性返回 <code>Map</code> 结构的成员总数。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'foo'</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">'bar'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><h6 id="操作方法-1"><a href="#操作方法-1" class="headerlink" title="操作方法"></a>操作方法</h6><ul>
<li><code>Map.prototype.set(key, value)</code>，<code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 <code>Map</code> 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">'edition'</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">'standard'</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">'nah'</span>)    <span class="comment">// 键是 undefined</span></span><br></pre></td></tr></table></figure></li>
<li><code>set</code>方法返回的是当前的Map对象，因此可以采用链式写法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">'b'</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> n = m.set(<span class="string">"a"</span>, <span class="string">"asS"</span>);</span><br><span class="line">m.set(<span class="string">"b"</span>, <span class="string">"xsdcwc"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);  <span class="comment">//Map(2) &#123;"a" =&gt; "asS", "b" =&gt; "xsdcwc"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(n);  <span class="comment">//Map(2) &#123;"a" =&gt; "asS", "b" =&gt; "xsdcwc"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(m === n);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><code>Map.prototype.get(key)</code></li>
<li><code>Map.prototype.has(key)</code></li>
<li><code>Map.prototype.delete(key)</code>，<code>delete</code>方法删除某个键，返回<code>true</code>，如果删除失败，返回<code>false</code>。</li>
<li><code>Map.prototype.clear()</code>，没有返回值。</li>
</ul>
<h6 id="遍历方法-1"><a href="#遍历方法-1" class="headerlink" title="遍历方法"></a>遍历方法</h6><ul>
<li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li>
<li><code>Map.prototype.values()</code>：返回键值的遍历器。</li>
<li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li>
<li><code>Map.prototype.forEach()</code>：遍历 <code>Map</code> 的所有成员。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'F'</span>, <span class="string">'no'</span>],</span><br><span class="line">  [<span class="string">'T'</span>,  <span class="string">'yes'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F"</span></span><br><span class="line"><span class="comment">// "T"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "no"</span></span><br><span class="line"><span class="comment">// "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br></pre></td></tr></table></figure></li>
<li>上面代码最后的那个例子，表示 <code>Map</code> 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">map[<span class="built_in">Symbol</span>.iterator] === map.entries</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Map与其它数据结构转换"><a href="#Map与其它数据结构转换" class="headerlink" title="Map与其它数据结构转换"></a>Map与其它数据结构转换</h4><ul>
<li><code>Map</code> 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[...map.values()]</span><br><span class="line"><span class="comment">// ['one', 'two', 'three']</span></span><br><span class="line"></span><br><span class="line">[...map.entries()]</span><br><span class="line"><span class="comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span></span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line"><span class="comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span></span><br></pre></td></tr></table></figure></li>
<li>对象转为 Map 可以通过<code>Object.entries()</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure></li>
<li>如果所有 <code>Map</code> 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">'yes'</span>, <span class="literal">true</span>)</span><br><span class="line">  .set(<span class="string">'no'</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure></li>
<li>与<code>JSON</code>的转换，可以通过对象或者字符串为中介，进行转换。</li>
</ul>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><h4 id="与Map区别"><a href="#与Map区别" class="headerlink" title="与Map区别"></a>与Map区别</h4><ul>
<li>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</li>
<li>其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>
</ul>
<h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li>WeakMap只有四个方法可用：<code>get()、set()、has()、delete()</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// size、forEach、clear 方法都不存在</span></span><br><span class="line">wm.size <span class="comment">// undefined</span></span><br><span class="line">wm.forEach <span class="comment">// undefined</span></span><br><span class="line">wm.clear <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
<li>下面代码中，先新建一个 <code>Weakmap</code> 实例。然后，将一个 <code>DOM</code>节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 <code>WeakMap</code> 里面。这时，<code>WeakMap</code> 里面对element的引用就是弱引用，不会被计入垃圾回收机制。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">* <span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">'some information'</span>);</span><br><span class="line">wm.get(element) <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure></li>
<li>也就是说，上面的 <code>DOM</code> 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</li>
<li>注意，<code>WeakMap</code> 弱引用的只是键名，而不是键值。键值依然是正常引用。上面代码中，键值obj是正常引用。所以，即使在 <code>WeakMap</code> 外部消除了obj的引用，<code>WeakMap</code> 内部的引用依然存在。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.get(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><code>WeakMap</code> 应用的典型场合就是 <code>DOM</code> 节点作为键名。下面是一个例子。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>),</span><br><span class="line">  &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(<span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>));</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ES6学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
